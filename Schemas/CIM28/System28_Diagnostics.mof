// ===================================================================
// Title:       System Diagnostics 2.8
// Filename:    System28_Diagnostics.mof
// Version:     2.8
// Status:      Final
// Date:        Jan 26, 2004
// ===================================================================
// Copyright 1999-2003 Distributed Management Task Force, Inc. (DMTF).
// All rights reserved.
// DMTF is a not-for-profit association of industry members dedicated
// to promoting enterprise and systems management and interoperability.
// DMTF specifications and documents may be reproduced for uses
// consistent with this purpose by members and non-members,
// provided that correct attribution is given.
// As DMTF specifications may be revised from time to time,
// the particular version and release date should always be noted.
// 
// Implementation of certain elements of this standard or proposed
// standard may be subject to third party patent rights, including
// provisional patent rights (herein "patent rights"). DMTF makes
// no representations to users of the standard as to the existence
// of such rights, and is not responsible to recognize, disclose, or
// identify any or all such third party patent right, owners or
// claimants, nor for any incomplete or inaccurate identification or
// disclosure of such rights, owners or claimants. DMTF shall have no
// liability to any party, in any manner or circumstance, under any
// legal theory whatsoever, for failure to recognize, disclose, or
// identify any such third party patent rights, or for such party's
// reliance on the standard or incorporation thereof in its product,
// protocols or testing procedures. DMTF shall have no liability to
// any party implementing such standard, whether such implementation
// is foreseeable or not, nor to any patent owner or claimant, and shall
// have no liability or responsibility for costs or losses incurred if
// a standard is withdrawn or modified after publication, and shall be
// indemnified and held harmless by any party implementing the
// standard from any and all claims of infringement by a patent owner
// for such implementations.
// 
// For information about patents held by third-parties which have
// notified the DMTF that, in their opinion, such patent may relate to
// or impact implementations of DMTF standards, visit
// http://www.dmtf.org/about/policies/disclosures.php.
// ===================================================================
// Description: The System Model defines system related management
//              concepts. This file defines the specific concepts for
//              Diagnostics.
// 
//              The object classes below are listed in an order that
//              avoids forward references. Required objects, defined
//              by other working groups, are omitted.
// ==================================================================
// Change Log for 2.8 Final
// CR1204 - Removal of Experimental Qualifier for Preliminary to Final
//        - all diagnostics kept as experimental for 2.9 prelim
// CR1184 - Change the Boolean declaration to boolean for
//          DiagnosticTest.DiscontinueTest(TestingStopped)
// CR1223 - SysDev Omnibus MOF corrections.
// 
// Change Log for 2.8 Preliminary
// CR947 - Add new record types
// CR945 - Change description of ResultPersistence to apply to LogRecord
// CR944 - IsSynchronous DiagnosticTest Characteristic and Miscellaneous
//          cleanup related to PercentOfTestCoverage and IsPackage
// CR937  - Localization
// CR946 - Deprecate DiagnosticResult and add needed
//        properties to DiagnosticServiceRecord
// CR939 - Add verbosity setting for result messages
// CR1020 - Promote "Test" associations to "Service"
// CR1041 - Add Help service
// CR1091 - Cleanup of RunDiagnostic methods
// CR1092  - Move HelpService to new Core28_Help from
//           System28_Diagnostics
// CR1125 - Rename Verbosity to TestResultLevel since it is a
//          corollary of TestWarningLevel.  Clean up descriptions
//          in LogOptions.
// CR1126 - DiagnosticServiceRecord vs. DiagnosticSettingRecord
// CR1130 - DiagnosticsServiceCapabilities model correspondance
//          corrections
// 
// Changes to bring forward from final
// CR726/CR1072 - Add LogOptions, OtherLogOptionDescriptions to
//         DiagnosticSetting and DiagnosticResult
//         Deprecate ReportSoftErrors and ReportStatusMessages from
//         DiagnosticSetting and DiagnosticResult
// CR764/CR1076 - Add DiagnosticService
//       - Change subclassing of DiagnosticTest from Service to
//         DiagnosticService
//       - Deprecation DiagnosticTest.ResourcesUsed and DiagnosticTest.
//         IsInUse
//       - Fix the Class Name in the ModelCorrespondence string for
//         DiagnosticTest.OtherCharacteristicDescription
// CR765/CR1077 - Update the the DiagnoticTest and DiagnosticResult
//         LogOptions property
//       - Modify the description of DiagnosticResult.TestResults
// CR779/CR1073 - Add DiagnosticService.RunDiagnostic()
//       - Deprecate DiagnosticTest.RunTest()
//       - Deprecate DiagnosticTest.DiscontinueTest()
//       - Update class description for DiagnosticTest
// CR780/CR1074 - Add DiagnosticServiceCapabilities
// CR781/CR1075 - Add DiagnosticServiceRecord
// CR887/CR1078 - Fix the DiagnosticService.RunDiagnostic return range
// for
//         Method Reserved.
// CR888/CR1079 - Correct DateTime format in the description of
//         DiagnosticResult.TestResults
// CR889/CR1080 - For consistency change the deprecation statement in
//         RunTest to reference the class where the RunDiagnostic
//         is defined (DiagnosticService).
// 
// Change Log for v2.7 Final
// CR1010 - Update DiagnosticResult.TestResults Description
//          related to datetime
// CR965 - Update description for DiagnosticTestForMSE
// CR973 - Remove Experimental from
//         DiagnosticSetting.LoopControlParameter
//         DiagnosticSetting.LoopControl
//         DiagnosticSetting.OtherLoopControlDescription
//         DiagnosticSetting.ResultPersistence
//         DiagnosticResult.ErrorCode
//         DiagnosticResult.ErrorCount
//         DiagnosticResult.LoopsFailed
//         DiagnosticResult.LoopsPassed
//         DiagnosticResult.LoopControlParameter
//         DiagnosticResult.LoopControl
//         DiagnosticResult.OtherLoopControlDescription
//         DiagnosticResult.ResultPersistence
//       - Move forward with the deprecations
//         DiagnosticResult.IsPackage
//         DiagnosticTest.IsinUse
//         DiagnosticTest.ResourcesUsed
//         DiagnosticResultInPackage
//         DiagnosticTestInPackage
//         DiagnosticTest.RunTest
//         DiagnosticSetting. and DiagnosticResult.ReportSoftErrors
//         DiagnosticSetting. and DiagnosticResult.ReportStatusMessages
//       - Hold off the rest of the Diagnostic deprecations and
//         experimental classes and properties until 2.8 (this
//         includes DiagnosticService, DiagnosticServiceRecord and
//         DiagnosticServiceCapabilities)
// 
// Change Log for v2.7
// CR725 - Add the following 3 properties LoopControlParameter,
//         LoopControl, and OtherLoopControlDescription to
//         DiagnosticSetting and DiagnosticResult
// CR749 - Deprecate DiagnosticTestInPackage, DiagnosticResultInPackage,
//         and DiagnosticResult.IsPackage
// CR766 - Add the following properties to DiagnosticResult:
//         ErrorCode, ErrorCount, LoopsFailed, LoopsPassed
// CR778 - Add property ResultPersistence to DiagnosticSetting and
//         DiagnosticResult
// ===================================================================

#pragma locale ("en_US")


// ==================================================================
// DiagnosticSetting
// ==================================================================
   [Version ( "2.7.0" ), Description (
       "Specific diagnostic test parameters and execution instructions "
       "are defined by subclassing and/or instantiating the "
       "DiagnosticSetting object. To provide more detailed Settings "
       "for a type of test (i.e., additional properties), subclassing "
       "is appropriate. When only the generic Setting information is "
       "required, instantiation of the Diagnostic Setting class may "
       "suffice. \n"
       "Data from DiagnosticSetting is captured in DiagnosticResult. "
       "When RunTest starts execution the settings, which are time "
       "sensitive, should be evaluated and captured. This is suggested "
       "since the DiagnosticSetting object can be modified at any "
       "time, and therefore the current test settings could be lost.")]
class CIM_DiagnosticSetting : CIM_Setting {

      [Key, Override ( "SettingID" ), Description (
          "The identifier by which the DiagnosticSetting object is "
          "known and uniquely named. One possible naming scheme is to "
          "name the SettingID using the DiagnosticTest's CreationClass "
          "Name and DiagnosticName, plus a GUID (Globally Unique "
          "IDentifier). \n"
          "Note that at an enterprise level, there is typically not a "
          "one to one mapping between a DiagnosticSetting and all "
          "copies of the DiagnosticTest. The proposed naming "
          "convention will scale to the entrprise level."), 
       MaxLen ( 256 )]
   string SettingID;

      [Write, Description (
          "Sets the level of warning messages to be logged. If for "
          "example no warning information is required, the level would "
          "be set to \"No Warnings\" (value=0). Using \"Missing "
          "Resources\" (value=1) will cause warnings to be generated "
          "when required resources or hardware are not found. Setting "
          "the value to 2, \"Testing Impacts\", results in both "
          "missing resources and 'test impact' warnings (for example, "
          "multiple retries required) to be reported."), 
       ValueMap { "0", "1", "2", "3" }, 
       Values { "No Warnings", "Missing Resources", "Testing Impacts",
          "All Warnings" }]
   uint16 TestWarningLevel;

      [Write, Description (
          "When this flag is true, the diagnostic test will report "
          "'soft errors'. In this context, a soft error is a message "
          "from the diagnostic reporting a known defect in the "
          "hardware or driver configuration, or execution environment. "
          "Examples are: 'Not enough memory', 'Driver IOCTL not "
          "implemented', 'Video RAM compare failed during polygon fill "
          "test (A known defect in the video chipset)', etc.")]
   boolean ReportSoftErrors;

      [Write, Description (
          "When this flag is true, the diagnostic test will report "
          "'status messages'. In this context, a status message "
          "indicates that the diagnostic code is at a checkpoint. "
          "Examples are: \"Completion of phase 1\", \"Complex "
          "pattern\", etc.")]
   boolean ReportStatusMessages;

      [Write, Description (
          "When this flag is true, the test will halt after finding "
          "the first error.")]
   boolean HaltOnError;

      [Write, Description (
          "When this flag is true, the test software should attempt to "
          "run in an accelerated fashion either by reducing the "
          "coverage or number of tests performed.")]
   boolean QuickMode;

      [Write, Description (
          "Requests the diagnostic software to reduce test coverage to "
          "the specified percentage. For example, a hard drive scan "
          "test could be asked to run at 50%. The most effective way "
          "to accomplish this is for the test software to scan every "
          "other track, as opposed to only scanning the first half of "
          "a drive. It is assumed that the effectiveness of the test "
          "is impacted proportional to the percentage of testing "
          "requested. Permissible values for this property range from "
          "0 to 100. \n"
          "This property may not be applicable to all tests. If it can "
          "be set for a test, the value 7 (\"Supports PercentOf "
          "TestCoverage\") should be entered into the DiagnosticTest's "
          "Characteristics array."), 
       Units ( "Percent" ), MinValue ( 0 ), MaxValue ( 100 ), 
       ModelCorrespondence { "CIM_DiagnosticTest.Characteristics" }]
   uint8 PercentOfTestCoverage;

      [Write, Description (
          "Array entries contain parameters corresponding to entries "
          "in the LoopControl array, limiting the number of times a "
          "test should be repeated with a single invocation of RunTest "
          "by a CIM client."), 
       ArrayType ( "Indexed" ), 
       ModelCorrespondence { "CIM_DiagnosticSetting.LoopControl" }]
   string LoopControlParameter[];

      [Write, Description (
          "LoopControl, used in conjunction with LoopControlParameter, "
          "sets one or more loop control mechanisms that limits the "
          "number of times a test should be repeated with a single "
          "invocation of RunTest by a CIM client. There is an "
          "array-positional correspondence between LoopControl entries "
          "& LoopControlParameter entries. The entries in these "
          "coupled arrays of loop controls can be used in a logical OR "
          "fashion to achieve the desired loop control. For example, "
          "if a client wants to loop a test 1000 times, but quit if a "
          "timer runs out, it could set both controls into the "
          "LoopControl array as two separate entries in each array. "
          "The looping test will terminate when the first of the two "
          "ORed conditions are met. \n"
          "The descriptions for each loop control are given below: \n"
          "Unknown/Default (= 0) \n"
          "Other (= 1) : Additional detail may be found in "
          "OtherLoopControlDescription. \n"
          "Continuous (= 2) : The corresponding LoopControl Parameter "
          "is ignored and the test will execute continuously. Tests "
          "that use this control should also support DiscontinueTest. "
          "\nCount(=3): The corresponding LoopControlParameter is "
          "interpreted as a loop count (uint32), indicating the number "
          "of times the test should be repeated with a single "
          "invocation of RunTest by a CIM client. \n"
          "Timer (= 4) : The corresponding LoopControlParameter is "
          "interpreted as an initial value (uint32) for a test loop "
          "timer, given in seconds. The looping is terminated when "
          "this timer has lapsed. \n"
          "ErrorCount (= 5) : The corresponding LoopControl Parameter "
          "is interpreted as an error count (uint32). The loop will "
          "continue until the number of errors that have occurred "
          "exceeds the ErrorCount. Note: the ErrorCount only refers to "
          "hard test errors; it does not include soft errors or "
          "warnings."), 
       ValueMap { "0", "1", "2", "3", "4", "5" }, 
       Values { "Unknown/Default", "Other", "Continuous", "Count",
          "Timer", "Error Count" }, ArrayType ( "Indexed" ), 
       ModelCorrespondence { 
          "CIM_DiagnosticSetting.LoopControlParameter",
          "CIM_DiagnosticSetting.OtherLoopControlDescription" }]
   uint16 LoopControl[];

      [Write, Description (
          "Provides additional information for LoopControl when its "
          "value is set to 1 ('Other')."), 
       ModelCorrespondence { 
          "CIM_DiagnosticSetting.LoopControlParameter" }]
   string OtherLoopControlDescription;

      [Write, Description (
          "The ResultPersistence property is a directive from a "
          "diagnostic client to a diagnostic provider. It allows the "
          "client to specify to the diagnostic service provider how "
          "long to persist the messages that result from execution of "
          "a diagnostic service. This applies to instances of "
          "DiagnosticResult. The timeout period starts upon completion "
          "of the diagnostic action described by the DiagnosticTest. \n"
          "Here is a summary of the choices and behaviors for "
          "different ResultPersistence values: \n"
          "0 = \"No Persistence\": \n"
          "Setting the timer to zero tells the provider not to persist "
          "the diagnostic result. The diagnostic information is only "
          "available while the diagnostic is executing or at its "
          "conclusion. \n"
          "Value > 0 and < 0xFFFFFFFF = \"Persist With TimeOut\": \n"
          "Setting the ResultPersistenceOption to a integer will cause "
          "the DiagnosticResult to be persisted for that number of "
          "seconds. At the end of that time, the DiagnosticResult may "
          "be deleted by the diagnostic service provider. \n"
          "0xFFFFFFFF = \"Persist Forever\": \n"
          "By setting the timeout value to the very large value, "
          "0xFFFFFFFF, the provider shall persist results forever. In "
          "this case, the client MUST bear the responsibility for "
          "deleting them."), 
       Units ( "Seconds" )]
   uint32 ResultPersistence;
};


// ==================================================================
// DiagnosticResult
// ==================================================================
   [Version ( "2.7.0" ), Description (
       "When a DiagnosticTest Service is running, test results are "
       "reported using a DiagnosticResult object, or one of its "
       "subclasses. A DiagnosticTest may be running because its "
       "Service is Started or due to an invocation of the RunTest "
       "method. DiagnosticResults are related to their Test via an "
       "instance of the DiagnosticResultForMSE association. \n"
       "For every running of DiagnosticTest, a new instance of "
       "DiagnosticResult, or one of it's subclasses should be created.")]
class CIM_DiagnosticResult {

      [Key, Propagated ( "CIM_DiagnosticTest.CreationClassName" ), 
       Description (
          "The scoping Test's CreationClassName."), 
       MaxLen ( 256 )]
   string DiagnosticCreationClassName;

      [Key, Propagated ( "CIM_DiagnosticTest.Name" ), Description (
          "The scoping Test's Name."), 
       MaxLen ( 256 )]
   string DiagnosticName;

      [Key, Propagated ( "CIM_DiagnosticTest.SystemCreationClassName" ), 
       Description (
          "The scoping Test's SystemCreationClassName."), 
       MaxLen ( 256 )]
   string DiagSystemCreationClassName;

      [Key, Propagated ( "CIM_DiagnosticTest.SystemName" ), 
       Description (
          "The scoping Test's SystemName."), 
       MaxLen ( 256 )]
   string DiagSystemName;

      [Key, Description (
          "The Unique identifier for an instance of Diagnostic "
          "Results."), 
       MaxLen ( 1024 )]
   string ExecutionID;

      [Description (
          "The date and time the result was last updated.")]
   datetime TimeStamp;

      [Deprecated { "No value" }, Description (
          "This property is being deprecated. Tests should be grouped "
          "at the test level, not by the model. /n If this property is "
          "TRUE, then this DiagnosticResult summarizes the results "
          "from the execution of a packaged set of DiagnosticTests. "
          "The Tests in the package can be identified by following the "
          "DiagnosticResultForTest association to the test and then "
          "using the DiagnosticTest InPackage aggregation. The "
          "individual Results can be broken out by instantiating "
          "DiagnosticResult for the individual lower level tests and "
          "aggregating into the 'summary' Result using the "
          "DiagnosticResultInPackage association.")]
   boolean IsPackage;

      [Description (
          "The date and time when this test started.")]
   datetime TestStartTime;

      [Description (
          "The date and time when this test completed.")]
   datetime TestCompletionTime;

      [Description (
          "Describes how the test is progressing. For example, if the "
          "test was discontinued, the TestState will be \"Stopped\" "
          "(value=5), or if testing is currently executing, TestState "
          "will be \"In Progress\" (4)."), 
       ValueMap { "0", "1", "2", "3", "4", "5" }, 
       Values { "Unknown", "Other", "Passed", "Failed", "In Progress",
          "Stopped" }, 
       ModelCorrespondence { 
          "CIM_DiagnosticResult.OtherStateDescription" }]
   uint16 TestState;

      [Description (
          "When \"Other\" (value=1) is entered in the TestState "
          "property, OtherStateDescription can be used to describe the "
          "test's state."), 
       ModelCorrespondence { "CIM_DiagnosticResult.TestState" }]
   string OtherStateDescription;

      [Description (
          "Estimated number of seconds to perform the Diagnostic Test "
          "indicated by the DiagnosticCreationClassName and "
          "DiagnosticName properties. After the test has completed, "
          "the actual elapsed time can be determined by subtracting "
          "the TestStartTime from the TestCompletionTime. A similar "
          "property is defined in the association, DiagnosticTest "
          "ForMSE. The difference between the two properties is that "
          "the value stored in the association is a generic test "
          "execution time for the Element and the Test. But, the value "
          "here (in DiagnosticResult) is the estimated time that this "
          "instance with the given settings would take to run the "
          "test. A CIM Consumer can compare this value with the value "
          "in the association DiagnosticTestForMSE to get an idea what "
          "impact their settings have on test execution."), 
       Units ( "Seconds" ), 
       ModelCorrespondence { 
          "CIM_DiagnosticTestForMSE.EstimatedTimeOfPerforming" }]
   uint32 EstimatedTimeOfPerforming;

      [Description (
          "TestResults stores one or more textual results from the "
          "execution of the DiagnosticTest(s) referenced by the "
          "DiagnosticCreationClassName and DiagnosticName properties. "
          "Note that this property is defined as an 'ordered' array "
          "type, to maintain the order in which the results are "
          "stored. One entry is considered a cell location in the "
          "array. Each entry is time stamped and contains information "
          "in the following format: CIMDateTime|TestName|MessageText, "
          "where: \n"
          "\"CIMDateTime\" is the standard CIM data type with the "
          "following format: yyyymmddhhmmss.mmmmmmsutc, where \n"
          "yyyy = year, e.g. 2003 \n"
          "mm = month (01 - 12) \n"
          "dd = day (01 - 31) \n"
          "hh = hour (00 - 24) \n"
          "mm = minute (00-59) \n"
          "ss = second (00-59) \n"
          "mmmmmm = microsecond (000000-999999) \n"
          "s = \"+\" or \"-\" indicating the sign of the UTC "
          "correction field \n"
          "utc = offset from UTC (Universal Coordinated Time) in "
          "minutes \n"
          "\"TestName\" is the name of the internal test that produced "
          "the message \n"
          "\"MessageText\" is a free form string that is the 'test "
          "result' \n"
          "\"|\" is a delimiter character."), 
       ArrayType ( "Ordered" )]
   string TestResults[];

      [Description (
          "The percentage of the test that has executed thus far, if "
          "the TestState property is set to \"In Progress\" or the "
          "percentage of the complete test that was executed if the "
          "TestState property is set to any of the completed states "
          "(\"Passed\", \"Failed\" or \"Stopped\"). Final results may "
          "be based on less than 100% coverage due to the parameters "
          "defined in DiagnosticSetting (such as QuickMode, "
          "PercentOfTestCoverage or HaltOnError)."), 
       Units ( "Percent" ), MinValue ( 0 ), MaxValue ( 100 )]
   uint8 PercentComplete;

      [Description (
          "If applicable, this string should contain one or more "
          "vendor specific error codes that the diagnostic service "
          "detected. These error codes may be used by the vendor for "
          "variety of purposes such as: fault data base indexing, "
          "field service trouble ticketing, product quality tracking, "
          "part failure history, etc. Since these codes are for vendor "
          "purposes they may assume any form. Details on suggested use "
          "cases will be left to white papers. The array of error "
          "codes has model correspondence with an ErrorCount array so "
          "the number of errors reported can be analyzed by individual "
          "error code."), 
       ArrayType ( "Indexed" ), 
       ModelCorrespondence { "CIM_DiagnosticResult.ErrorCount" }]
   string ErrorCode[];

      [Description (
          "Since some tests may detect transient and correctable "
          "errors such as a network diagnostic or memory test, an "
          "error count is useful to indicate the severity of the "
          "failure. This field contains an integer value of the number "
          "of errors detected by the test. The ErrorCount is an array "
          "with model correspondence to ErrorCode so that the test can "
          "report an ErrorCount on each type of error encountered. It "
          "is recommended that hard errors and correctable or "
          "recoverable errors be given different codes so that clients "
          "with knowledge of the error codes can evaluate correctable, "
          "recoverable, and hard errors independently."), 
       ArrayType ( "Indexed" ), 
       ModelCorrespondence { "CIM_DiagnosticResult.ErrorCode" }]
   uint32 ErrorCount[];

      [Description (
          "Since some tests may be looped, it is useful to report how "
          "many iterations passed and failed. This is relevant in "
          "analyzing transitory failures. For example, if all the "
          "errors occurred in just one of 100 iterations, the device "
          "may be viewed as OK or marginal, to be monitored further "
          "rather then failed. Note: LoopsPassed & LoopsFailed should "
          "add up to the loops completed.")]
   uint32 LoopsFailed;

      [Description (
          "Since some tests may be looped, it is useful to report how "
          "many iterations passed and failed. This is relevant in "
          "analyzing transitory failures. For example if all the "
          "errors occurred in in just one of 100 iterations, the "
          "device may be viewed as OK or marginal, to be monitored "
          "further rather then failed. Note: LoopsPassed & LoopsFailed "
          "should add up to the loops completed.")]
   uint32 LoopsPassed;

// ---------  Properties below here are copied from  ------------------
// ---------  DiagnosticSettings                     ------------------
// Note that the DiagnosticSetting object can be modified at any time,
// and the current test settings can be lost. When RunTest starts
// execution the settings, which are time sensitive, should be evaluated
// and captured.

      [Description (
          "Sets the level of warning messages to be logged. If for "
          "example no warning information is required, the level would "
          "be set to \"No Warnings\" (value=0). Using \"Missing "
          "Resources\" (value=1) will cause warnings to be generated "
          "when required resources or hardware are not found. Setting "
          "the value to 2, \"Testing Impacts\", results in both "
          "missing resources and 'test impact' warnings (for example, "
          "multiple retries required) to be reported."), 
       ValueMap { "0", "1", "2", "3" }, 
       Values { "No Warnings", "Missing Resources", "Testing Impacts",
          "All Warnings" }, 
       ModelCorrespondence { "CIM_DiagnosticSetting.TestWarningLevel" }]
   uint16 TestWarningLevel;

      [Description (
          "When this flag is true, the diagnostic test reports 'soft "
          "errors'. In this context, a soft error is a message from "
          "the diagnostic, reporting a known defect in the hardware or "
          "driver configuration, or execution environment. Examples "
          "are: 'Not enough memory', 'Driver IOCTL not implemented', "
          "'Video RAM compare failed during polygon fill test (A known "
          "defect in the video chipset)', etc."), 
       ModelCorrespondence { "CIM_DiagnosticSetting.ReportSoftErrors" }]
   boolean ReportSoftErrors;

      [Description (
          "When this flag is true, the diagnostic test reports 'status "
          "messages'. In this context, a status message indicates that "
          "the diagnostic code is at a checkpoint. Examples are: "
          "\"Completion of phase 1\", \"Complex pattern\", etc."), 
       ModelCorrespondence { 
          "CIM_DiagnosticSetting.ReportStatusMessages" }]
   boolean ReportStatusMessages;

      [Description (
          "When this flag is true, the test halts after finding the "
          "first error."), 
       ModelCorrespondence { "CIM_DiagnosticSetting.HaltOnError" }]
   boolean HaltOnError;

      [Description (
          "When this flag is true, the test software attempts to run "
          "in an accelerated fashion either by reducing the coverage "
          "or number of tests performed."), 
       ModelCorrespondence { "CIM_DiagnosticSetting.QuickMode" }]
   boolean QuickMode;

      [Description (
          "Specifies the test coverage performed by the diagnostic. "
          "For example, a hard drive scan test could be asked to run "
          "at 50%. The most effective way to accomplish this is for "
          "the test software to scan every other track, as opposed to "
          "only scanning the first half of a drive. It is assumed that "
          "the effectiveness of the test is impacted proportional to "
          "the percentage of testing performed. Permissible values for "
          "this property range from 0 to 100."), 
       Units ( "Percent" ), MinValue ( 0 ), MaxValue ( 100 ), 
       ModelCorrespondence { 
          "CIM_DiagnosticSetting.PercentOfTestCoverage" }]
   uint8 PercentOfTestCoverage;

      [Description (
          "Array entries contain parameters corresponding to entries "
          "in the LoopControl array, limiting the number of times a "
          "test should be repeated with a single invocation of RunTest "
          "by a CIM client."), 
       ArrayType ( "Indexed" ), 
       ModelCorrespondence { 
          "CIM_DiagnosticSetting.LoopControlParameter",
          "CIM_DiagnosticResult.LoopControl" }]
   string LoopControlParameter[];

      [Description (
          "LoopControl, used in conjunction with LoopControlParameter, "
          "sets one or more loop control mechanisms that limits the "
          "number of times a test should be repeated with a single "
          "invocation of RunTest by a CIM client. There is an "
          "array-positional correspondence between LoopControl entries "
          "& LoopControlParameter entries. The entries in these "
          "coupled arrays of loop controls can be used in a logical OR "
          "fashion to achieve the desired loop control. For example, "
          "if a client wants to loop a test 1000 times, but quit if a "
          "timer runs out, it could set both controls into the "
          "LoopControl array as two separate entries in each array. "
          "The looping test will terminate when the first of the two "
          "ORed conditions are met. \n"
          "The descriptions for each loop control are given below: \n"
          "Unknown/Default (= 0) \n"
          "Other (= 1) : Additional detail may be found in "
          "OtherLoopControlDescription. \n"
          "Continuous (= 2) : The corresponding LoopControl Parameter "
          "is ignored and the test will execute continuously. Tests "
          "that use this control should also support DiscontinueTest. "
          "\nCount(=3): The corresponding LoopControlParameter is "
          "interpreted as a loop count (uint32), indicating the number "
          "of times the test should be repeated with a single "
          "invocation of RunTest by a CIM client. \n"
          "Timer (= 4) : The corresponding LoopControlParameter is "
          "interpreted as an initial value (uint32) for a test loop "
          "timer, given in seconds. The looping is terminated when "
          "this timer has lapsed. \n"
          "ErrorCount (= 5) : The corresponding LoopControl Parameter "
          "is interpreted as an error count (uint32). The loop will "
          "continue until the number of errors that have occurred "
          "exceeds the ErrorCount. Note: the ErrorCount only refers to "
          "hard test errors; it does not include soft errors or "
          "warnings."), 
       ValueMap { "0", "1", "2", "3", "4", "5" }, 
       Values { "Unknown/Default", "Other", "Continuous", "Count",
          "Timer", "Error Count" }, ArrayType ( "Indexed" ), 
       ModelCorrespondence { "CIM_DiagnosticSetting.LoopControl",
          "CIM_DiagnosticResult.LoopControlParameter",
          "CIM_DiagnosticResult.OtherLoopControlDescription" }]
   uint16 LoopControl[];

      [Description (
          "Provides additional information for LoopControl when its "
          "value is set to 1 ('Other')."), 
       ModelCorrespondence { 
          "CIM_DiagnosticSetting.OtherLoopControlDescription",
          "CIM_DiagnosticResult.LoopControlParameter" }]
   string OtherLoopControlDescription;

      [Description (
          "The ResultPersistence property is a directive from a "
          "diagnostic client to a diagnostic provider. It allows the "
          "client to specify to the diagnostic service provider how "
          "long to persist the messages that result from execution of "
          "a diagnostic service. This applies to instances of "
          "DiagnosticResult. The timeout period starts upon completion "
          "of the diagnostic action described by the DiagnosticTest. \n"
          "Here is a summary of the choices and behaviors for "
          "different ResultPersistence values: \n"
          "0 = \"No Persistence\": \n"
          "Setting the timer to zero tells the provider not to persist "
          "the diagnostic result. The diagnostic information is only "
          "available while the diagnostic is executing or at its "
          "conclusion. \n"
          "Value > 0 and < 0xFFFFFFFF = \"Persist With TimeOut\": \n"
          "Setting the ResultPersistenceOption to a integer will cause "
          "the DiagnosticResult to be persisted for that number of "
          "seconds. At the end of that time, the DiagnosticResult may "
          "be deleted by the diagnostic service provider. \n"
          "0xFFFFFFFF = \"Persist Forever\": \n"
          "By setting the timeout value to the very large value, "
          "0xFFFFFFFF, the provider shall persist results forever. In "
          "this case, the client MUST bear the responsibility for "
          "deleting them."), 
       Units ( "Seconds" ), 
       ModelCorrespondence { "CIM_DiagnosticSetting.ResultPersistence" 
          }]
   uint32 ResultPersistence;
};


// ==================================================================
// DiagnosticTest
// ==================================================================
   [Version ( "2.6.0" ), Description (
       "The CIM_DiagnosticTest class represents the framework for "
       "running diagnostic tests. Specific diagnostic tests may be "
       "defined by subclassing and/or instantiating this object. To "
       "provide more detail for a type of test(s) (i.e, additional "
       "properties and methods), subclassing is appropriate. Note that "
       "a DiagnosticTest can be simultaneously executed against "
       "several elements. If so, a DiagnosticTest may launch a "
       "ConcreteJob to represent each execution.")]
class CIM_DiagnosticTest : CIM_Service {

      [Description (
          "The descriptions for each Characteristic are below: \n"
          "\n"
          "* \"Is Exclusive\" (value=2) is specified for the test "
          "module only if the diagnostic cannot run more than one test "
          "at a time, regardless of how many SystemElements are "
          "supported. Typically, this occurs when hardware or software "
          "constraints prevent the test from running as multiple, "
          "concurrent instances. If the diagnostic can be run against "
          "multiple SystemElements, but only once per Element, then "
          "set the IsExclusiveForMSE boolean property on the "
          "appropriate instances of DiagnosticTestForMSE. \n"
          "\n"
          "* If \"Is Interactive\" (value=3) is set, then the "
          "diagnostic displays a message either before, during or "
          "after testing. \n"
          "\n"
          "* Set \"Is Destructive\" (value=4) if the diagnostic will "
          "destroy data, or reconfigure the Element that is being "
          "tested. \n"
          "\n"
          "* \"Is Risky\" (value=5) indicates that data loss may occur "
          "if the test is interrupted. Some tests make copies of data, "
          "perform the test, and restore the data returning the tested "
          "entity to its previous configuration. If the test is "
          "interrupted, then loss of data or reconfiguration of the "
          "tested ManagedSystemElement may occur. \n"
          "\n"
          "* If \"Is Package\" (value=6) is set, this test is actually "
          "a set of lower level diagnostics, that are 'packaged' "
          "together. \n"
          "\n"
          "\"Supports PercentOfTestCoverage\" (value=7) indicates that "
          "a request for reduced test coverage can be specified using "
          "the PercentOfTestCoverage property of Diagnostic Setting. \n"
          "\n"
          "Also, the values \"Unknown\" (0) and \"Other\" (1) may be "
          "specified. If \"Other\" is defined, additional detail may "
          "be found in the OtherCharacteristicDescription property of "
          "this class."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6", "7" }, 
       Values { "Unknown", "Other", "Is Exclusive", "Is Interactive",
          "Is Destructive", "Is Risky", "Is Package",
          "Supports PercentOfTestCoverage" }, 
       ModelCorrespondence { 
          "CIM_DiagnosticTest.OtherCharacteristicDescription" }]
   uint16 Characteristics[];

      [Description (
          "Provides additional information for the Characteristic when "
          "its value is set to 1 (\"Other\")."), 
       ModelCorrespondence { "CIM_DiagnosticTest.Characteristics" }]
   string OtherCharacteristicDescription;

      [Description (
          "If this test is currently being performed, the InUse "
          "property is set to TRUE. To determine which ManagedSystem "
          "Element is being tested, query the DiagnosticResult objects "
          "associated with this test (query DiagnosticResultForTest), "
          "and for which the TestState equals 4 (\"In Progress\"). The "
          "DiagnosticResult object is associated with the System "
          "Element under test, using DiagnosticResultForMSE.")]
   boolean IsInUse;

      [Description (
          "The \"Expensive\" qualifier can be applied to this class "
          "and its RunTest method. If so, the ResourcesUsed property "
          "describes the resources that are capitalized, based on a "
          "default setup for the test. Multiple resources can be "
          "specified since the property is an array."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
          "10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
          "20", "21", "22", "23", "24", "25", "26" }, 
       Values { "CPU", "Memory", "Hard Disk", "CDROM", "Floppy",
          "PCI Bus", "USB Bus", "1394 Bus", "SCSI Bus", "IDE Bus",
          "Network", "ISA Bus", "EISA Bus", "VESA Bus", "PCMCIA Bus",
          "CardBus", "Access.bus", "NuBus", "AGP", "VME Bus",
          "Sbus IEEE 1396-1993", "MCA Bus", "GIO Bus", "XIO Bus",
          "HIO Bus", "PMC Bus", "SIO Bus" }]
   uint16 ResourcesUsed[];

      [Description (
          "The RunTest method executes this diagnostic for the "
          "specified ManagedSystemElement (defined using the "
          "SystemElement input parameter). Results of the test are "
          "stored in a DiagnosticResult object, a reference to which "
          "is returned as the Result output parameter. How the test "
          "should execute, i.e. its settings, is defined in a "
          "DiagnosticSetting object (or by a subclass of "
          "DiagnosticSetting). A reference to a Setting object is "
          "specified using the Setting input parameter. If a reference "
          "is not passed into the method, then a default "
          "DiagnosticSetting may be used. This default Setting is "
          "associated with the DiagnoticTest using the DefaultSetting "
          "relationship of the Core Model. \n"
          "When RunTest starts execution, the settings, which are time "
          "sensitive, should be evaluated and captured. This is "
          "suggested since the DiagnosticSetting object can be "
          "modified at any time, and therefore the current test "
          "settings could be lost. \n"
          "The method's return codes are expected to adhere to the XML "
          "return codes as they are introduced. Currently, the "
          "standard return values are: \n"
          "0 = OK (function succeeded, but the test itself may have "
          "failed \n"
          "1 = Unspecified Error (function failed for unspecified "
          "reasons) \n"
          "2 = Not Implemented (function is not implemented for this "
          "instance) \n"
          "3 = Out Of Resources (component could not allocate required "
          "resources, e.g. memory, disk space, etc.) \n"
          "In a subclass, the set of possible return codes could be "
          "specified, using a ValueMap qualifier on the method. The "
          "strings to which the ValueMap contents are 'translated' may "
          "also be specified in the subclass as a Values array "
          "qualifier.")]
   uint32 RunTest( 
         [IN, Description (
             "The ManagedSystemElement on which the test will run.")]
      CIM_ManagedSystemElement REF SystemElement, 
         [IN, Description (
             "How the test should execute, i.e. its settings, is "
             "defined in a DiagnosticSetting object (or by a subclass "
             "of DiagnosticSetting). A reference to a Setting object "
             "is specified using the Setting input parameter. If a "
             "reference is not passed into the method, then a default "
             "DiagnosticSetting may be used. This default Setting is "
             "associated with the DiagnoticTest using the "
             "DefaultSetting relationship of the Core Model.")]
      CIM_DiagnosticSetting REF Setting, 
         [IN ( false ), OUT, Description (
             "Results of the test are stored in a DiagnosticResult "
             "object, a reference to which is returned as the Result "
             "output parameter.")]
      CIM_DiagnosticResult REF Result); 

      [Description (
          "Execution of this method will delete all instances of the "
          "DiagnosticResultForMSE object, for this DiagnosticTest and "
          "the specified ManagedSystemElement (defined using the "
          "SystemElement input parameter). The DiagnosticResults "
          "referenced in the DiagnosticResultForMSE instances will be "
          "deleted. Also the association DiagnosticResultForTest that "
          "refers to the DiagnosticResult object, and this test will "
          "be deleted. \n"
          "One output parameter is defined - ResultsNotCleared - which "
          "is a string array that lists the keys of the "
          "DiagnosticResults which could not be deleted. This "
          "information enables those Results to be revisited and "
          "either manually removed, or other corrective action taken. "
          "\nThemethod'sreturncodes are expected to adhere to the XML "
          "return codes as they are introduced. Currently, the "
          "standard return values are: \n"
          "0 = OK (function succeeded, but the test itself may have "
          "failed) \n"
          "1 = Unspecified Error (function failed for unspecified "
          "reasons) \n"
          "2 = Not Implemented (function is not implemented for this "
          "instance) \n"
          "3 = Out Of Resources (component could not allocate required "
          "resources, e.g. memory, disk space, etc.) \n"
          "In a subclass, the set of possible return codes could be "
          "specified, using a ValueMap qualifier on the method. The "
          "strings to which the ValueMap contents are 'translated' may "
          "also be specified in the subclass as a Values array "
          "qualifier.")]
   uint32 ClearResults( 
         [IN, Description (
             "The Managed System Element for which results will be "
             "cleared.")]
      CIM_ManagedSystemElement REF SystemElement, 
         [IN ( false ), OUT, Description (
             "A string array that lists the keys of the "
             "DiagnosticResults which could not be deleted.")]
      string ResultsNotCleared[]); 

      [Description (
          "After invocation of this method and its completion, the "
          "specified test(s) will be discontinued for the indicated "
          "ManagedSystemElement (defined by the SystemElement input "
          "parameter). The test to discontinue is specified using the "
          "Result input parameter. If all instances of this test "
          "should be stopped for the SystemElement, then the Result "
          "reference should be NULL. Upon completion of the method, "
          "test status and other information (such as PercentComplete) "
          "will be stored in the DiagnosticResult instance defined by "
          "the Result input parameter. The output parameter, "
          "TestingStopped, is used as follows: \n"
          "Set to TRUE if testing was successfully stopped. \n"
          "Set to FALSE if the current test(s) can not be stopped. \n"
          "If set to FALSE, testing will stop when the diagnostic is "
          "able to do so safely. To determine if/when the testing is "
          "stopped, check the TestState property in the "
          "DiagnosticResult instance defined by the Result parameter. "
          "TestState will change from \"In Progress\" to \"Stopped\" "
          "(from 4 to 5). \n"
          "The method's return codes are expected to adhere to the XML "
          "return codes as they are introduced. Currently, the "
          "standard return values are: \n"
          "0 = OK (function succeeded, but the test itself may have "
          "failed \n"
          "1 = Unspecified Error (function failed for unspecified "
          "reasons) \n"
          "2 = Not Implemented (function is not implemented for this "
          "instance) \n"
          "3 = Out Of Resources (component could not allocate required "
          "resources, e.g. memory, disk space, etc.) \n"
          "In a subclass, the set of possible return codes could be "
          "specified, using a ValueMap qualifier on the method. The "
          "strings to which the ValueMap contents are 'translated' may "
          "also be specified in the subclass as a Values array "
          "qualifier.")]
   uint32 DiscontinueTest( 
         [IN, Description (
             "Testing will be discontinued for the indicated "
             "ManagedSystemElement defined by the SystemElement input "
             "parameter.")]
      CIM_ManagedSystemElement REF SystemElement, 
         [IN, Description (
             "The test to discontinue is specified using the Result "
             "input parameter.")]
      CIM_DiagnosticResult REF Result, 
         [IN ( false ), OUT, Description (
             "TestingStopped, is set to TRUE if testing was "
             "successfully stopped. It is set to FALSE if the current "
             "test(s) can not be stopped. If set to FALSE, testing "
             "will stop when the diagnostic is able to do so safely. "
             "To determine if/when the testing is stopped, check the "
             "TestState property in the DiagnosticResult instance "
             "defined by the Result parameter. TestState will change "
             "from \"In Progress\" to \"Stopped\" (from 4 to 5).")]
      boolean TestingStopped); 

};


// ==================================================================
// DiagnosticResultForMSE
// ==================================================================
   [Association, Version ( "2.6.0" ), Description (
       "This is an association class relating diagnostic test results "
       "to the ManagedSystemElement that is/was tested.")]
class CIM_DiagnosticResultForMSE {

      [Key, Description (
          "The diagnostic result.")]
   CIM_DiagnosticResult REF Result;

      [Key, Description (
          "The ManagedSystemElement to which the diagnostic result "
          "applies.")]
   CIM_ManagedSystemElement REF SystemElement;
};


// ==================================================================
// DiagnosticResultForTest
// ==================================================================
   [Association, Version ( "2.6.0" ), Description (
       "This is an association class to relate the results of a test "
       "to the test itself.")]
class CIM_DiagnosticResultForTest {

      [Key, Weak, Min ( 1 ), Max ( 1 ), Description (
          "The result object.")]
   CIM_DiagnosticResult REF DiagnosticResult;

      [Key, Min ( 1 ), Max ( 1 ), Description (
          "The test that generated the result object.")]
   CIM_DiagnosticTest REF DiagnosticTest;
};


// ==================================================================
// DiagnosticTestForMSE
// ==================================================================
   [Association, Version ( "2.6.0" ), Description (
       "This is an association class that relates a DiagnosticTest to "
       "a ManagedSystemElement. Consumers wishing to 'diagnose' a "
       "particular Element could query this association, for the "
       "Element, to determine what tests are available. Examining the "
       "DiagnosticTestForMSE class definition, note that its "
       "superclass ProvidesServiceToElement is deprecated. "
       "Unfortunately, ProvidesServiceToElement cannot be removed from "
       "the object hierarchy without a major Schema release. When/if "
       "this occurs, the ProvidesServiceToElement superclass will be "
       "removed, and DiagnosticTestForMSE will subclass from "
       "CIM_Dependency directly.")]
class CIM_DiagnosticTestForMSE : CIM_ProvidesServiceToElement {

      [Override ( "Antecedent" ), Description (
          "The test that may be run against a ManagedSystemElement.")]
   CIM_DiagnosticTest REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The ManagedSystemElement that can be tested.")]
   CIM_ManagedSystemElement REF Dependent;

      [Description (
          "Estimated number of seconds to perform the referenced "
          "DiagnosticTest against the ManagedSystemElement. Since "
          "execution times could vary by Element, this property is "
          "located in the association between the two entities. It is "
          "also captured in DiagnosticResult, in the Estimated "
          "TimeOfPerforming property. \n"
          "A CIM Consumer can compare this value with the value in "
          "DiagnosticResult to get an idea of what impact their "
          "settings have on test execution."), 
       Units ( "Seconds" ), 
       ModelCorrespondence { 
          "CIM_DiagnosticResult.EstimatedTimeOfPerforming" }]
   uint32 EstimatedTimeOfPerforming;

      [Description (
          "If the DiagnosticTest referenced in this object can be run "
          "concurrently against multiple SystemElements, but only run "
          "one at a time for the referenced ManagedSystemElement, then "
          "this boolean is set to TRUE. Alternately, if the test can "
          "NOT be run concurrently irregardless of the System Elements "
          "being tested, then the more general \"Is Exclusive\" "
          "enumerated value (2) should be set in DiagnosticTest. "
          "Characteristics.")]
   boolean IsExclusiveForMSE;
};


// ==================================================================
// DiagnosticTestInPackage
// ==================================================================
   [Association, Deprecated { "No value" }, Aggregation,
       Version ( "2.7.0" ), Description (
       "This class is being deprecated. Tests should be grouped at the "
       "test level, not in the model. Therefore, the association is "
       "not appropriate. /n This is an association class that "
       "identifies a Diagnostic Test as made up of lower level Tests. "
       "In this case, the test identified as the GroupComponent "
       "reference (i.e, the higher level test) would have the \"Is "
       "Package\" enumerated value specified in DiagnosticTest. "
       "Characteristics.")]
class CIM_DiagnosticTestInPackage : CIM_Component {

      [Deprecated { "No value" }, Aggregate,
          Override ( "GroupComponent" ), Description (
          "The DiagnosticTest object that acts as the container for "
          "all the tests of the package.")]
   CIM_DiagnosticTest REF GroupComponent;

      [Deprecated { "No value" }, Override ( "PartComponent" ), 
       Description (
          "The DiagnosticTest object that is one of the elements of "
          "the package.")]
   CIM_DiagnosticTest REF PartComponent;
};


// ==================================================================
// DiagnosticResultInPackage
// ==================================================================
   [Association, Deprecated { "No value" }, Aggregation,
       Version ( "2.7.0" ), Description (
       "This class is being deprecated. Tests should be grouped at the "
       "test level, not by the model. Therefore, this association is "
       "no longer appropriate. /n This is an association class that "
       "identifies a Diagnostic Result as made up of lower level "
       "Results. In this case, the Result identified as the "
       "PackageResult reference (i.e., the higher level result) would "
       "have its IsPackage property set to TRUE.")]
class CIM_DiagnosticResultInPackage {

      [Deprecated { "No value" }, Key, Aggregate, Description (
          "The DiagnosticResult object that acts as the container for "
          "all the results of the package.")]
   CIM_DiagnosticResult REF PackageResult;

      [Deprecated { "No value" }, Key, Description (
          "The DiagnosticResult object that is one of the elements of "
          "the package.")]
   CIM_DiagnosticResult REF Result;
};


// ==================================================================
// DiagnosticSettingForTest
// ==================================================================
   [Association, Version ( "2.6.0" ), Description (
       "This is an association class to relate test settings with "
       "diagnostic tests.")]
class CIM_DiagnosticSettingForTest : CIM_ElementSetting {

      [Override ( "Element" ), Description (
          "The Test that can use the Setting object.")]
   CIM_DiagnosticTest REF Element;

      [Override ( "Setting" ), Description (
          "The Setting that can be applied to the execution of the "
          "DiagnosticTest.")]
   CIM_DiagnosticSetting REF Setting;
};


// ===================================================================
// end of file
// ===================================================================
