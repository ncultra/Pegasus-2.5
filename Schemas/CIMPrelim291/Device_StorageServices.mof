// ===================================================================
// Title:  Device Storage Services
// $State: Exp $
// $Date: 2005/02/24 20:05:58 $
// $Source: /cvs/MSB/pegasus/Schemas/CIMPrelim291/Device_StorageServices.mof,v $
// $Revision: 1.1 $
// ===================================================================
//#pragma inLine ("Includes/copyright.inc")
// Copyright 1998-2005 Distributed Management Task Force, Inc. (DMTF).
// All rights reserved.
// DMTF is a not-for-profit association of industry members dedicated
// to promoting enterprise and systems management and interoperability.
// DMTF specifications and documents may be reproduced for uses
// consistent with this purpose by members and non-members,
// provided that correct attribution is given.
// As DMTF specifications may be revised from time to time,
// the particular version and release date should always be noted.
// 
// Implementation of certain elements of this standard or proposed
// standard may be subject to third party patent rights, including
// provisional patent rights (herein "patent rights"). DMTF makes
// no representations to users of the standard as to the existence
// of such rights, and is not responsible to recognize, disclose, or
// identify any or all such third party patent right, owners or
// claimants, nor for any incomplete or inaccurate identification or
// disclosure of such rights, owners or claimants. DMTF shall have no
// liability to any party, in any manner or circumstance, under any
// legal theory whatsoever, for failure to recognize, disclose, or
// identify any such third party patent rights, or for such party's
// reliance on the standard or incorporation thereof in its product,
// protocols or testing procedures. DMTF shall have no liability to
// any party implementing such standard, whether such implementation
// is foreseeable or not, nor to any patent owner or claimant, and shall
// have no liability or responsibility for costs or losses incurred if
// a standard is withdrawn or modified after publication, and shall be
// indemnified and held harmless by any party implementing the
// standard from any and all claims of infringement by a patent owner
// for such implementations.
// 
// For information about patents held by third-parties which have
// notified the DMTF that, in their opinion, such patent may relate to
// or impact implementations of DMTF standards, visit
// http://www.dmtf.org/about/policies/disclosures.php.
//#pragma inLine
// ===================================================================
// Description: The Device Model extends the management concepts that
//              are related to LogicalDevices. This file defines
//              a model for storage services.
// 
//              The object classes below are listed in an order that
//              avoids forward references. Required objects, defined
//              by other working groups, are omitted.
// ==================================================================
// Change Log for v2.9 Preliminary Company Review
// CR1449 - Missing other element types from GetSupported* methods
//          on StoragePool
// CR1427 - Add a method to scan for SCSI configuration changes.
// 
// Change Log for v2.9 Preliminary
// CR1293 - Add GetAvailableExtents to StoragePool
// CR1331 - Add CreateOrModifyElementFromElements to Storage
//          Configuration Service.
// CR1376 - Add "InExtents" to Values of
//          StorageConfigurationCapabilities.
//          SupportedStorageElementFeatures for support of
//          CreateOrModifyStoragePool method.
//  CR1328 - StorageCapabilities and StorageSettings: Settings
//           not associated
//  CR1329 - Incorporate additional properties in StorageConfiguration
//           (and Settings) to better describe RAID levels.
// 
// Change Log for v2.8 Final
//  CR1279 - Add LogicalDisk to supported element types in
//  StorageServices
// 
// Change Log for v2.8 Final
//  CR1171 - Add WRITE qualifiers to StorageSetting.x
//  CR1151 -  Clarify description of
//  AllocatedFromStoragePool.SpaceConsummed
//  CR1227 - Missing commas in ModelCorrespondences in StorageSetting
//  CR1202 - Remove Experimental to Final for Device
//  CR1223 - Omnibus SysDev Cr - minor MOF corrections
// 
// Change Log for v2.8 Preliminary
//  CR997  - clarify StorageEfficiencyHint
//  CR1028 - Add CreateSetting to StorageCapabilities
//  CR1033 - Extent copy services.
//  CR1044 - Add:
//             StoragePool.TotalManagedSpace
//             StoragePool.TotalAvailableSpace
//             StoragePool.Primordial
//         - Remove TotalAvailableSpace
//  CR1046 - Add StorageConfigurationCapabilities
//  CR1141 - Correction of StorageSynchronized.SyncState.
// 
// Change Log for v2.7.1
//       - Fix MaxValue declarations in StorageSettingWithHints - the
//         properties, AccessDirectionHint and AccessBandwidthWeight
// 
// Change Log for v2.7 Final
// CR970 - Removal of the Experimental qualifier
//       - Remove StoragePool.GetSupportedSize and StoragePool.
//         GetSupportedSizeRange so they can remain experimental in 2.8
// CR978 - Clarify the use of settings and capabilities
//       - Change 'spindle' to 'package'
//       - Add ElementType in StoragePool methods
//       - Add ElementName to creation methods
//       - Fix ValueMap issues
//       - Generalize the "goal" parameter in CreateOrModifyElement
//       - Change units from megabytes to bytes.
// CR994 - Update description for InstanceID
// 
// Change Log for v2.7
// CR775 - Add StorageSetting, StoragePool, StorageCapabilities,
//         StorageConfigurationService, StorageSettingsWithHints,
//         HostedStoragePool, and AllocatedStoragePool
// CR759 - Add ConfigurationReportingService
// CR777 - Add StorageSynchrononized
//         Add StorageSetting.DeltaReservation,
//         StorageCpabilities.DeltaReservationMin,
//         StorageCpabilities.DeltaReservationMax,
//         StorageCpabilities.DeltaReservationDefault,
//         StorageConfigurationService.CreateReplica() and
//         StorageConfigurationService.ModifySynchronization()
// CR895 - Correct the method return Values/ValueMaps for all the
//         methods in the ConfigurationReportingService.
// ==================================================================

#pragma locale ("en_US")


// ==================================================================
// StorageSynchronized
// ==================================================================
   [Association, Version ( "2.8.0" ), Description (
       "Indicates that two Storage objects were replicated at the "
       "specified point in time. If the CopyType property is set to "
       "'Sync' (=3), then synchronization of the Storage objects is "
       "preserved.")]
class CIM_StorageSynchronized : CIM_Synchronized {

      [Override ( "SystemElement" ), Description (
          "SystemElement represents the Storage that is the source of "
          "the replication.")]
   CIM_ManagedElement REF SystemElement;

      [Override ( "SyncedElement" ), Description (
          "SyncedElement represents the Storage that is the target of "
          "the replication.")]
   CIM_ManagedElement REF SyncedElement;

      [Description (
          "CopyType describes the Replication Policy. Values are: \n"
          "Async: create and maintain an asynchronous copy of the "
          "source. \n"
          "Sync: create and maintain a synchronized copy of the "
          "source. \n"
          "UnSyncAssoc: create an unsynchronized copy and maintain an "
          "association to the source."), 
       ValueMap { "2", "3", "4", "..", "0x8000.." }, 
       Values { "Async", "Sync", "UnSyncAssoc", "DMTF Reserved",
          "Vendor Specific" }]
   uint16 CopyType;

      [Description (
          "ReplicaType provides information on how the Replica is "
          "being maintained. Values are: \n"
          "Full Copy: This indicates that a full copy of the source "
          "object is (or will be) generated . \n"
          "Before Delta: This indicates that the source object will be "
          "maintained as a delta data from the replica. \n"
          "After Delta: This indicates that the replica will be "
          "maintained as delta data from the source object. \n"
          "Log: This indicates that the replica object is being "
          "maintained as a log of changes to the source. \n"
          "Not Specified: The method of maintaining the copy is not "
          "specified."), 
       ValueMap { "0", "2", "3", "4", "5","..", "0x8000.." }, 
       Values { "Not Specified", "Full Copy", "Before Delta",
          "After Delta", "Log","DMTF Reserved", "Vendor Specific" }]
   uint16 ReplicaType;

      [Description (
          "SyncState describes the state of the association with "
          "respect to Replication activity. Values are: \n"
          "Initialized: The link to enable replication is established. "
          "\nPrepareInProgress: Preparation for Replication is in "
          "progress. \n"
          "Prepared: All necessary preparation has completed. \n"
          "ResyncInProgress: Synchronization or Resynchronization is "
          "in progress. \n"
          "This may be the initial 'copy' or subsequent changes being "
          "copied. \n"
          "Synchronized: An Async or Sync replication is currently "
          "synchronized. When this value is set, SyncMaintained will "
          "be true. \n"
          "FractureInProgress: An operation to fracture an Async or "
          "Sync replication is in progress. \n"
          "Fractured: An Async or Sync replication is fractured. \n"
          "QuiesceInProgress: A quiesce operation is in progress. \n"
          "Quiesced: The replication has been quiesced and is ready "
          "for a change. \n"
          "RestoreInProgress: An operation is in progress to copy the "
          "Synced object to the System object. \n"
          "Idle: The 'normal' state for an UnSyncAssoc replica. \n"
          "Broken: The relationship is non-functional due to errors in "
          "the source, the target, the path between the two or space "
          "constraints."), 
       ValueMap { "2", "3", "4", "5", "6", "7", "8", "9", "10", "11",
          "12", "13", "..", "0x8000.." }, 
       Values { "Initialized", "PrepareInProgress", "Prepared",
          "ResyncInProgress", "Synchronized", "Fracture In Progress",
          "QuiesceInProgress", "Quiesced", "Restore In Progresss",
          "Idle", "Broken", "Fractured", "DMTF Reserved",
          "Vendor Specific" }]
   uint16 SyncState;
};


// ==================================================================
// StorageSetting
// ==================================================================
   [Version ( "2.8.1000" ), Description (
       "StorageSetting is roughly equivalent to a Service Level "
       "Agreement (SLA) It defines the characteristics, qualities of "
       "service and goals when used in a CreateOrModifyElement "
       "FromStoragePool or CreateOrModifyStoragePool method in the "
       "StorageConfigurationService. It specifies a series of "
       "properties with Maximum and Minimum values that define the "
       "(inclusive) bounds that the object should maintain. Note that "
       "the setting is associated to a StorageVolume or LogicalDisk, "
       "using ElementSetting. \n"
       "The use of these properties differs depending on whether the "
       "StorageSetting instance is being used as a goal for a "
       "configuration operation or being used as a Service Level "
       "Agreement for a created Volume. In addition the properties "
       "fall into two categories: The QOS "
       "properties(PackageRedundancy, Data Redundancy, & "
       "NoSinglePointOfFailure) and the Detailed RAID "
       "properties(ExtentStripeLength, ParityLayout, and "
       "UserDataStripeDepth). In a Setting used as a goal, the QOS "
       "properties are required as a set; The Detailed RAID "
       "properties(if supported as indicated by the scoping "
       "StorageCapabilities instance) may be used optionally in any "
       "combination. The implementation MUST supply it's own best "
       "practice in the case where one or more supported RAID "
       "properties are not supplied. In this situation the use of "
       "StorageSettingWithHints can be useful to provide direction to "
       "the implementation. \n"
       "In a Setting used as a service agreement for a Volume, the QOS "
       "properties reflect the Service Level Agreement, with goal, "
       "min, & max. The actual current service level is exposed by "
       "corresponding values in StorageExtent. \n"
       "The Detailed RAID properties, by contrast, reflect specific "
       "values that reflect the RAID construction of the Volume. Only "
       "the primary values are meaningful; Min and Max are set to "
       "match. \n"
       "Certain StorageSetting instances may be classed as \"Fixed\", "
       "by using the \"ChangeableType\" property, indicating the "
       "setting is preset. Such settings are used when the possible "
       "setting variations are low enough to be instantiated in their "
       "entirety. The StorageCapabilities \"CreateSetting\" method MAY "
       "NOT be used to return settings that are not changeable. \n"
       "Other StorageSetting instances are created using the "
       "\"CreateSetting\" method. If the capabilities specifies "
       "ranges, then the setting can be used by a client to narrow the "
       "range to particular values within the range. In other words, "
       "the capabilities MAY be broad, but the related setting MUST be "
       "as capable or less capable, that is more narrowly defined, "
       "before it is used to create or modify resources. \n"
       "These created StorageSetting instances MUST have their "
       "\"ChangeableType\" property = 1, \"Changeable - Transient\". \n"
       "GeneratedSettings MAY not remain after the restart or reset of "
       "the implementation. They may be deleted by implementation at "
       "any time. A reasonable minimal time to retain the generated "
       "transient settings is five minutes, although there is no "
       "minimal retention time.")]
class CIM_StorageSetting : CIM_SettingData {

      [Write, Description (
          "Indicates the desired value for No Single Point of Failure. "
          "Possible values are false = single point of failure, and "
          "true = no single point of failure.")]
   boolean NoSinglePointOfFailure;

      [Write, Description (
          "DataRedundancyMax describes the maximum number of complete "
          "copies of data to be maintained. Examples would be RAID 5 "
          "where 1 copy is maintained and RAID 1 where 2 or more "
          "copies are maintained. Possible values are 1 to n. The "
          "desired redundancy is specified using DataRedundancyGoal, "
          "while the minimum is defined by DataRedundancyMin."), 
       MinValue ( 1 ), 
       ModelCorrespondence { "CIM_StorageSetting.DataRedundancyMin",
          "CIM_StorageSetting.DataRedundancyGoal" }]
   uint16 DataRedundancyMax;

      [Write, Description (
          "DataRedundancyMin describes the minimum number of complete "
          "copies of data to be maintained. Examples would be RAID 5 "
          "where 1 copy is maintained and RAID 1 where 2 or more "
          "copies are maintained. Possible values are 1 to n. The "
          "desired redundancy is specified using DataRedundancyGoal, "
          "while the maximum is defined by DataRedundancyMax."), 
       MinValue ( 1 ), 
       ModelCorrespondence { "CIM_StorageSetting.DataRedundancyMax",
          "CIM_StorageSetting.DataRedundancyGoal" }]
   uint16 DataRedundancyMin;

      [Write, Description (
          "DataRedundancyGoal describes the desired number of complete "
          "copies of data to be maintained. Examples would be RAID 5 "
          "where 1 copy is maintained and RAID 1 where 2 or more "
          "copies are maintained. Possible values are 1 to n. The "
          "bounds (max and min) for redundancy are defined using the "
          "properties, DataRedundancyMax and DataRedundancyMin."), 
       MinValue ( 1 ), 
       ModelCorrespondence { "CIM_StorageSetting.DataRedundancyMax",
          "CIM_StorageSetting.DataRedundancyMin" }]
   uint16 DataRedundancyGoal;

      [Write, Description (
          "PackageRedundancyMax describes the maximum number of "
          "redundant packages to be used. For example, in the storage "
          "domain, package redundancy describes how many disk spindles "
          "can fail without data loss including, at most, one spare. "
          "An example would be RAID5 with a spare disk which would "
          "have a PackageRedundancy of 2. Possible values are 0 to n. "
          "The desired redundancy is specified using "
          "PackageRedundancyGoal, while the minimum is defined by "
          "PackageRedundancyMin."), 
       ModelCorrespondence { "CIM_StorageSetting.PackageRedundancyMin",
          "CIM_StorageSetting.PackageRedundancyGoal" }]
   uint16 PackageRedundancyMax;

      [Write, Description (
          "PackageRedundancyMin describes the minimum number of "
          "redundant packages to be used. For example, in the storage "
          "domain, package redundancy describes how many disk spindles "
          "can fail without data loss including, at most, one spare. "
          "An example would be RAID5 with a spare disk which would "
          "have a PackageRedundancy of 2. Possible values are 0 to n. "
          "The desired redundancy is specified using "
          "PackageRedundancyGoal, while the maximum is defined by "
          "PackageRedundancyMax."), 
       ModelCorrespondence { "CIM_StorageSetting.PackageRedundancyMax",
          "CIM_StorageSetting.PackageRedundancyGoal" }]
   uint16 PackageRedundancyMin;

      [Write, Description (
          "PackageRedundancyGoal describes the desired number of "
          "redundant packages to be used. For example, in the storage "
          "domain, package redundancy describes how many disk spindles "
          "can fail without data loss including, at most, one spare. "
          "An example would be RAID5 with a spare disk which would "
          "have a PackageRedundancy of 2. Possible values are 0 to n. "
          "The bounds (max and min) for redundancy are defined using "
          "the properties, PackageRedundancyMax and "
          "PackageRedundancyMin."), 
       ModelCorrespondence { "CIM_StorageSetting.PackageRedundancyMax",
          "CIM_StorageSetting.PackageRedundancyMin" }]
   uint16 PackageRedundancyGoal;

      [Write, Description (
          "DeltaReservationMax is a number between 1 (1%) and a 100 "
          "(100%) which specifies the maximum amount of space that "
          "should be reserved in a replica for caching changes. For a "
          "complete copy this would be 100%. The desired reservation "
          "is specified using DeltaReservationGoal, while the minimum "
          "is defined by DeltaReservationMin."), 
       Units ( "Percentage" ), MinValue ( 1 ), MaxValue ( 100 ), 
       ModelCorrespondence { "CIM_StorageSetting.DeltaReservationMin",
          "CIM_StorageSetting.DeltaReservationGoal" }]
   uint8 DeltaReservationMax;

      [Write, Description (
          "DeltaReservationMin is a number between 1 (1%) and a 100 "
          "(100%) which specifies the minimum amount of space that "
          "should be reserved in a replica for caching changes. For a "
          "complete copy this would be 100%. The desired reservation "
          "is specified using DeltaReservationGoal, while the maximum "
          "is defined by DeltaReservationMax."), 
       Units ( "Percentage" ), MinValue ( 1 ), MaxValue ( 100 ), 
       ModelCorrespondence { "CIM_StorageSetting.DeltaReservationMax",
          "CIM_StorageSetting.DeltaReservationGoal" }]
   uint8 DeltaReservationMin;

      [Write, Description (
          "DeltaReservationGoal is a number between 1 (1%) and a 100 "
          "(100%) which specifies the desired amount of space that "
          "should be reserved in a replica for caching changes. For a "
          "complete copy this would be 100%. The bounds (max and min) "
          "for the reservation are defined using the properties, "
          "DeltaReservationMax and DeltaReservationMin."), 
       Units ( "Percentage" ), MinValue ( 1 ), MaxValue ( 100 ), 
       ModelCorrespondence { "CIM_StorageSetting.DeltaReservationMin",
          "CIM_StorageSetting.DeltaReservationMax" }]
   uint8 DeltaReservationGoal;

      [Experimental, Description (
          "Enumeration indicating the type of setting. \"Fixed - Not "
          "Changeable\" settings are primordial. These setting are "
          "defined at the implementor of the class. \"Changeable - "
          "Transient\" is the type of setting produced by the "
          "\"CreateSetting\" method. A client can subsequently request "
          "that the implementation persist the generated and "
          "potentially modified setting indefinately. Only a "
          "\"Changeable - Transient\" setting SHALL be converted to a "
          "\"Changeable = Persistent\" setting; the setting SHALL NOT "
          "be changed back."), 
       ValueMap { "0", "1", "2" }, 
       Values { "Fixed - Not Changeable", "Changeable - Transient",
          "Changeable - Persistent" }]
   uint16 ChangeableType;

      [Experimental, Write, Description (
          "ExtentStripeLength describes the number of underlying "
          "StorageExtents across which data is striped in the common "
          "striping-based storage organizations. This is also known as "
          "the number of 'members' or 'columns'. When used in a goal "
          "setting instance, ExtentStripeLength is the optimal desired "
          "value. The bounds (max and min) for Stripe Length are "
          "defined using the properties ExtentStripeLengthMax and "
          "ExtentStripeLengthMin. ExtentStripeLength MUST be set to "
          "NULL if the scoping StorageCapablities indicates that it is "
          "not supported in this context. ExtentStripeLength can be "
          "used in conjunction with CreateOrModifyElementFromELements "
          "to explicitly configure storage. An example would be RAID "
          "0+1 with mirroring two stripe sets, each set being three "
          "wide. In this case CreateOrModifyElementFromElements would "
          "be passed a goal setting with DataRedundancy = 2 and "
          "ExtentStripeLength = 3. The size of the InElements array "
          "would be 6 and would contain the StorageExtents to be used "
          "to construct the StorageElement as a RAID 0+1. "
          "ExtentStripeLengthMin and ExtentStripeLengthMax are "
          "meaningless and wouldbe set to NULL. If the property is "
          "supported, and is part of StorageSettingWithHints it MAY be "
          "set to NULL. If used it will constrain the effects of Hint "
          "selections. When used in a Setting instance associated to a "
          "Volume, this property indicates the specific value that the "
          "Volume was created with, and ExtentStripeLengthMin and "
          "ExtentStripeLengthMax will be set to the same specific "
          "value."), 
       MinValue ( 1 ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.ExtentStripeLengthMax",
          "CIM_StorageSetting.ExtentStripeLengthMin" }]
   uint16 ExtentStripeLength;

      [Experimental, Write, Description (
          "ExtentStripeLength describes the number of underlying "
          "StorageExtents across which data is striped in the common "
          "striping-based storage organizations. This is also known as "
          "the number of 'members' or 'columns'. When used in a goal "
          "setting instance, ExtentStripeLengthMin is the minimum "
          "acceptable value. The desired Stripe Length is specified "
          "using ExtentStripeLength, while the maximum is defined by "
          "ExtentStripeLengthMax. ExtentStripeLengthMin MUST be set to "
          "NULL if the scoping StorageCapablities indicates that it is "
          "not supported in this context. If the property is "
          "supported, and is part of StorageSettingWithHints it MAY be "
          "set to NULL. If used it will constrain the effects of Hint "
          "selections. When used in a Setting instance associated to a "
          "Volume, this property is set to the specific value of "
          "ExtentStripeLength."), 
       MinValue ( 1 ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.ExtentStripeLengthMax",
          "CIM_StorageSetting.ExtentStripeLength" }]
   uint16 ExtentStripeLengthMin;

      [Experimental, Write, Description (
          "ExtentStripeLength describes the number of underlying "
          "StorageExtents across which data is striped in the common "
          "striping-based storage organizations. This is also known as "
          "the number of 'members' or 'columns'. When used in a goal "
          "setting instance, ExtentStripeLengthMax is the maximum "
          "acceptable value. The desired Stripe Length is specified "
          "using ExtentStripeLength, while the minimum is defined by "
          "ExtentStripeLengthMin. ExtentStripeLengthMax MUST be set to "
          "NULL if the scoping StorageCapablities indicates that it is "
          "not supported in this context. If the property is "
          "supported, and is part of StorageSettingWithHints it MAY be "
          "set to NULL. If used it will constrain the effects of Hint "
          "selections. When used in a Setting instance associated to a "
          "Volume, this property is set to the specific value of "
          "ExtentStripeLength."), 
       MinValue ( 1 ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.ExtentStripeLengthMin",
          "CIM_StorageSetting.ExtentStripeLength" }]
   uint16 ExtentStripeLengthMax;

      [Experimental, Write, Description (
          "ParityLayout specifies whether a parity-based storage "
          "organization is using rotated or non-rotated parity. When "
          "used in a goal setting instance, ParityLayout is the "
          "desired value. It MUST be set to NULL if the scoping "
          "StorageCapablities indicates that it is not supported in "
          "this context. If the property is supported, and is part of "
          "StorageSettingWithHints it MAY be set to NULL. If used it "
          "will constrain the effects of Hint selections. When used in "
          "a Setting instance associated to a Volume, this property "
          "indicates the specific value that the Volume was created "
          "with."), 
       ValueMap { "1", "2" }, 
       Values { "Non-rotated Parity", "Rotated Parity" }]
   uint16 ParityLayout;

      [Experimental, Write, Description (
          "UserDataStripeDepth describes the number of bytes forming a "
          "strip in common striping-based storage organizations. The "
          "strip is defined as the size of the portion of a stripe "
          "that lies on one extent. Thus, ExtentStripeLength * "
          "UserDataStripeDepth will yield the size of one stripe of "
          "user data. When used in a goal setting instance, "
          "UserDataStripeDepth is the optimal desired value. The "
          "bounds (max and min) for Stripe Depth are defined using the "
          "properties UserDataStripeDepthMax and "
          "UserDataStripeDepthMin. UserDataStripeDepth MUST be set to "
          "NULL if the scoping StorageCapablities indicates that it is "
          "not supported in this context. If the property is "
          "supported, and is part of StorageSettingWithHints it MAY be "
          "set to NULL. If used it will constrain the effects of Hint "
          "selections. When used in a Setting instance associated to a "
          "Volume, this property indicates the specific value that the "
          "Volume was created with, and UserDataStripeDepthMin and "
          "UserDataStripeDepthMax will be set to the same specific "
          "value."), 
       Units ( "Bytes" ), MinValue ( 1 ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.UserDataStripeDepthMax",
          "CIM_StorageSetting.UserDataStripeDepthMin" }]
   uint64 UserDataStripeDepth;

      [Experimental, Write, Description (
          "UserDataStripeDepth describes the number of bytes forming a "
          "strip in common striping-based storage organizations. The "
          "strip is defined as the size of the portion of a stripe "
          "that lies on one extent. Thus, ExtentStripeLength * "
          "UserDataStripeDepth will yield the size of one stripe of "
          "user data. When used in a goal setting instance, "
          "UserDataStripeDepthMin is the minimum acceptable value. The "
          "desired Stripe Depth is specified using "
          "UserDataStripeDepth, while the maximum is defined by "
          "UserDataStripeDepthMax. UserDataStripeDepthMin MUST be set "
          "to NULL if the scoping StorageCapablities indicates that it "
          "is not supported in this context. If the property is "
          "supported, and is part of StorageSettingWithHints it MAY be "
          "set to NULL. If used it will constrain the effects of Hint "
          "selections. When used in a Setting instance associated to a "
          "Volume, this property is set to the specific value of "
          "UserDataStripeDepth."), 
       Units ( "Bytes" ), MinValue ( 1 ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.UserDataStripeDepthMax",
          "CIM_StorageSetting.UserDataStripeDepth" }]
   uint64 UserDataStripeDepthMin;

      [Experimental, Write, Description (
          "UserDataStripeDepth describes the number of bytes forming a "
          "strip in common striping-based storage organizations. The "
          "strip is defined as the size of the portion of a stripe "
          "that lies on one extent. Thus, ExtentStripeLength * "
          "UserDataStripeDepth will yield the size of one stripe of "
          "user data. When used in a goal setting instance, "
          "UserDataStripeDepthMax is the maximum acceptable value. The "
          "desired Stripe Depth is specified using "
          "UserDataStripeDepthGoal, while the minimum is defined by "
          "UserDataStripeDepthMin. UserDataStripeDepthMax MUST be set "
          "to NULL if the scoping StorageCapablities indicates that it "
          "is not supported in this context. If the property is "
          "supported, and is part of StorageSettingwWithHints it MAY "
          "be set to NULL. If used it will constrain the effects of "
          "Hint selections. When used in a Setting instance associated "
          "to a Volume, this property is set to the specific value of "
          "UserDataStripeDepth."), 
       Units ( "Bytes" ), MinValue ( 1 ), 
       ModelCorrespondence { 
          "CIM_StorageSetting.UserDataStripeDepthMin",
          "CIM_StorageSetting.UserDataStripeDepth" }]
   uint64 UserDataStripeDepthMax;
};


// ==================================================================
// StoragePool
// ==================================================================
   [Version ( "2.8.1000" ), Description (
       "A pool of Storage that is managed within the scope of a "
       "particular System. StoragePools may consist of component "
       "StoragePools or StorageExtents. StorageExtents that belong to "
       "the StoragePool have a Component relationship to the "
       "StoragePool. StorageExtents/StoragePools that are elements of "
       "a pool have their available space aggregated into the pool. "
       "StoragePools, StorageVolumes and LogicalDisks may be created "
       "from StoragePools. This is indicated by the "
       "AllocatedFromStoragePool association. StoragePool is scoped to "
       "a system by the HostedStoragePool association.")]
class CIM_StoragePool : CIM_LogicalElement {

      [Key, Description (
          "Within the scope of the instantiating Namespace, InstanceID "
          "opaquely and uniquely identifies an instance of this class. "
          "In order to ensure uniqueness within the NameSpace, the "
          "value of InstanceID SHOULD be constructed using the "
          "following 'preferred' algorithm: \n"
          "<OrgID>:<LocalID> \n"
          "Where <OrgID> and <LocalID> are separated by a colon ':', "
          "and where <OrgID> MUST include a copyrighted, trademarked "
          "or otherwise unique name that is owned by the business "
          "entity creating/defining the InstanceID, or is a registered "
          "ID that is assigned to the business entity by a recognized "
          "global authority (This is similar to the <Schema "
          "Name>_<Class Name> structure of Schema class names.) In "
          "addition, to ensure uniqueness <OrgID> MUST NOT contain a "
          "colon (':'). When using this algorithm, the first colon to "
          "appear in InstanceID MUST appear between <OrgID> and "
          "<LocalID>. \n"
          "<LocalID> is chosen by the business entity and SHOULD not "
          "be re-used to identify different underlying (real-world) "
          "elements. If the above 'preferred' algorithm is not used, "
          "the defining entity MUST assure that the resultant "
          "InstanceID is not re-used across any InstanceIDs produced "
          "by this or other providers for this instance's NameSpace. \n"
          "For DMTF defined instances, the 'preferred' algorithm MUST "
          "be used with the <OrgID> set to 'CIM'.")]
   string InstanceID;

      [Required, Description (
          "A unique name in the context of the System that identifies "
          "this pool."), 
       MaxLen ( 256 )]
   string PoolID;

      [Description (
          "If true, \"Primordial\" indicates that the containing "
          "System does not have the ability to create or delete this "
          "operational element. This is important because higher-level "
          "StoragePools may be assembled using the Component or "
          "AllocatedFromStoragePool associations. Although the "
          "higher-level abstractions can be created and deleted, the "
          "most basic, (i.e. primordial), hardware-based StoragePools "
          "cannot. They are physically realized as part of the System, "
          "or are actually managed by some other System and imported "
          "as if they were physically realized.")]
   boolean Primordial=false;

      [Description (
          "The total amount of raw storage (in bytes) managed by this "
          "StoragePool. This includes all of the bytes consumed to "
          "create the storage surfaced by this StoragePool, including "
          "all of the overhead bytes that are not reflected in the "
          "size of the logical storage allocated from this "
          "StoragePool. \n"
          "Conceptually TotalManagedSpace reflects all storage known "
          "via Component associations to underlying StorageExtents or "
          "via AllocatedFromStoragePool associations to underlying "
          "StoragePools. However, note that this underlying storage "
          "may not be surfaced by the instrumentation."), 
       Units ( "Bytes" ), 
       ModelCorrespondence { "CIM_StoragePool.RemainingManagedSpace" }]
   uint64 TotalManagedSpace;

      [Required, Description (
          "The remaining amount of raw storage (in bytes) from the "
          "TotalManagedSpace of this StoragePool. This property is "
          "maintained here to provide efficient access to this "
          "information. However, note that it is possible to compute "
          "RemainingManagedSpace as (TotalManagedSpace minus the sum "
          "of SpaceConsumed from all of the AllocatedFromStoragePool "
          "references from this StoragePool). Note that SpaceConsumed "
          "remains useful to determine the amount of raw storage "
          "consumed by a particular allocated element."), 
       Units ( "Bytes" ), 
       ModelCorrespondence { "CIM_StoragePool.TotalManagedSpace",
          "CIM_AllocatedFromStoragePool.SpaceConsumed" }]
   uint64 RemainingManagedSpace;

      [Description (
          "For pools that support discrete sizes for volume or pool "
          "creation, this method can be used to retrieve a list of "
          "supported sizes. Note that different pool implementations "
          "may support either or both the GetSupportedSizes and "
          "GetSupportedSizeRanges methods at different times, "
          "depending on Pool configuration. Also note that the "
          "advertised sizes may change after the call due to requests "
          "from other clients. If the pool currently only supports a "
          "range of sizes, then the return value will be set to 1."), 
       ValueMap { "0", "1", "2" }, 
       Values { "Method completed OK", "Method not supported",
          "Use GetSupportedSizeRange instead" }]
   uint32 GetSupportedSizes ( 
         [IN, Description (
             "The type of element for which supported sizes are "
             "reported for."), 
          ValueMap { "2", "3", "4" }, 
          Values { "Storage Pool", "Storage Volume", "Logical Disk" }]
      uint16 ElementType, 
         [IN, Description (
             "The StorageSetting for which supported sizes should be "
             "reported for.")]
      CIM_StorageSetting REF Goal, 
         [IN ( false ), OUT, Description (
             "List of supported sizes for a Volume/Pool creation or "
             "modification."), 
          Units ( "Bytes" )]
      uint64 Sizes[] ); 

      [Description (
          "For pools that that support a range of sizes for volume or "
          "pool creation, this method can be used to retrieve the "
          "supported range. Note that different pool implementations "
          "may support either or both the GetSupportedSizes and "
          "GetSupportedSizeRanges methods at different times, "
          "depending on Pool configuration. Also note that the "
          "advertised sizes may change after the call due to requests "
          "from other clients. If the pool currently only supports "
          "discrete sizes, then the return value will be set to 1."), 
       ValueMap { "0", "1", "2" }, 
       Values { "Method completed OK", "Method not supported",
          "Use GetSupportedSizes instead" }]
   uint32 GetSupportedSizeRange ( 
         [IN, Description (
             "The type of element for which supported size ranges are "
             "reported for."), 
          ValueMap { "2", "3", "4" }, 
          Values { "Storage Pool", "Storage Volume", "Logical Disk" }]
      uint16 ElementType, 
         [IN, Description (
             "The StorageSetting for which supported size ranges "
             "should be reported for.")]
      CIM_StorageSetting REF Goal, 
         [IN ( false ), OUT, Description (
             "The minimum size for a volume/pool in bytes."), 
          Units ( "Bytes" )]
      uint64 MinimumVolumeSize, 
         [IN ( false ), OUT, Description (
             "The maximum size for a volume/pool in bytes."), 
          Units ( "Bytes" )]
      uint64 MaximumVolumeSize, 
         [IN ( false ), OUT, Description (
             "A volume/pool size must be a multiple of this value "
             "which is specified in bytes."), 
          Units ( "Bytes" )]
      uint64 VolumeSizeDivisor); 

      [Experimental, Description (
          "This method can be used to retrieve a list of available "
          "Extents that may be used in the creation or modification of "
          "a StoragePool, StorageVolume, or LogicalDisk. The "
          "GetAvailableExtents method MUST return the Extents from the "
          "set of Component Extents of the Pool on which the method is "
          "being invoked. The returned Extents are available at the "
          "time the method returns. There is no guarantee that the "
          "same Extents will be available later. This method MUST "
          "return the Extents that are not being used as supporting "
          "capacity for any other Pools, Volumes, or LogicalDisks that "
          "have been allocated from this Pool. The Extent returned "
          "MUST be a component Extent of the Pool or subdivisions of a "
          "component Extent, the subdivisions themselves represented "
          "as Extents."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6", "..",
          "4098..32767", "32768..65535" }, 
       Values { "Completed with No Error", "Not Supported", "Unknown",
          "Timeout", "Failed", "Invalid Parameter", "In Use",
          "DMTF Reserved", "Method Reserved", "Vendor Specific" }]
   uint32 GetAvailableExtents ( 
         [IN, Description (
             "The StorageSetting (Goal) for which supported extents "
             "should be retrieved as available. \n"
             "If a NULL is passed for the Goal, the method will return "
             "all available extents, regardless of the goal. There "
             "exists a possibility of error in creating a Pool, "
             "Volume, or LogicalDisk retrieved in this manner.")]
      CIM_StorageSetting REF Goal, 
         [OUT, Description (
             "List of references to available StorageExtents, or "
             "subclass instances.")]
      CIM_StorageExtent REF AvailableExtents[] ); 
};


// ==================================================================
// StorageCapabilities
// ==================================================================
   [Version ( "2.8.1000" ), Description (
       "A subclass of Capabilities that defines the Capabilities of a "
       "StorageService or StoragePool. For example, an instance of "
       "StorageCapabilities could be associated with either a "
       "StorageConfigurationService or StoragePool by using "
       "ElementCapabilities.")]
class CIM_StorageCapabilities : CIM_Capabilities {

      [Description (
          "Enumeration indicating the type of element to which this "
          "StorageCapabilities applies."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6", "7" }, 
       Values { "Unknown", "Reserved", "Any Type", "StorageVolume",
          "StorageExtent", "StoragePool",
          "StorageConfigurationService", "LogicalDisk" }]
   uint16 ElementType;

      [Description (
          "Indicates whether or not the associated element supports no "
          "single point of failure. Values are: FALSE = does not "
          "support no single point of failure, and TRUE = supports no "
          "single point of failure."), 
       ModelCorrespondence { 
          "CIM_StorageCapabilities.NoSinglePointOfFailureDefault" }]
   boolean NoSinglePointOfFailure;

      [Description (
          "Indicates the default value for the NoSinglePointOfFailure "
          "property."), 
       ModelCorrespondence { 
          "CIM_StorageCapabilities.NoSinglePointOfFailure" }]
   boolean NoSinglePointOfFailureDefault;

      [Description (
          "DataRedundancyMax describes the maximum number of complete "
          "copies of data that can be maintained. Examples would be "
          "RAID 5 (where 1 copy is maintained) and RAID 1 (where 2 or "
          "more copies are maintained). Possible values are 1 to n. "
          "The default redundancy is specified using "
          "DataRedundancyDefault, while the minimum is defined by "
          "DataRedundancyMin."), 
       MinValue ( 1 ), 
       ModelCorrespondence { 
          "CIM_StorageCapabilities.DataRedundancyMin",
          "CIM_StorageCapabilities.DataRedundancyDefault" }]
   uint16 DataRedundancyMax;

      [Description (
          "DataRedundancyMin describes the minimum number of complete "
          "copies of data that can be maintained. Examples would be "
          "RAID 5 where 1 copy is maintained and RAID 1 where 2 or "
          "more copies are maintained). Possible values are 1 to n. "
          "The default redundancy is specified using "
          "DataRedundancyDefault, while the maximum is defined by "
          "DataRedundancyMax."), 
       MinValue ( 1 ), 
       ModelCorrespondence { 
          "CIM_StorageCapabilities.DataRedundancyMax",
          "CIM_StorageCapabilities.DataRedundancyDefault" }]
   uint16 DataRedundancyMin;

      [Description (
          "DataRedundancyDefault describes the default number of "
          "complete copies of data that can be maintained. Examples "
          "would be RAID 5 where 1 copy is maintained and RAID 1 where "
          "2 or more copies are maintained. Possible values are 1 to "
          "n. The bounds for the redundancy (max and min) are defined "
          "by DataRedundancyMax and DataRedundancyMin."), 
       MinValue ( 1 ), 
       ModelCorrespondence { 
          "CIM_StorageCapabilities.DataRedundancyMax",
          "CIM_StorageCapabilities.DataRedundancyMin" }]
   uint16 DataRedundancyDefault;

      [Description (
          "PackageRedundancyMax describes the maximum number of "
          "redundant packages that can be used. For example, in the "
          "storage domain, package redundancy describes how many disk "
          "spindles can fail without data loss including, at most, one "
          "spare. An example would be RAID5 with a spare disk which "
          "would have a PackageRedundancy of 2. Possible values are 0 "
          "to n. The default redundancy is specified using "
          "PackageRedundancyDefault, while the maximum is defined by "
          "PackageRedundancyMax."), 
       ModelCorrespondence { 
          "CIM_StorageCapabilities.PackageRedundancyMin",
          "CIM_StorageCapabilities.PackageRedundancyDefault" }]
   uint16 PackageRedundancyMax;

      [Description (
          "PackageRedundancyMin describes the minimum number of "
          "redundant packages that can be used. For example, in the "
          "storage domain, package redundancy describes how many disk "
          "spindles can fail without data loss including, at most, one "
          "spare. An example would be RAID5 with a spare disk which "
          "would have a PackageRedundancy of 2. Possible values are 0 "
          "to n. The default redundancy is specified using "
          "PackageRedundancyDefault, while the minimum is defined by "
          "PackageRedundancyMin."), 
       ModelCorrespondence { 
          "CIM_StorageCapabilities.PackageRedundancyMax",
          "CIM_StorageCapabilities.PackageRedundancyDefault" }]
   uint16 PackageRedundancyMin;

      [Description (
          "PackageRedundancyDefault describes the default number of "
          "redundant packages that will be used. For example, in the "
          "storage domain, package redundancy describes how many disk "
          "spindles can fail without data loss including, at most, one "
          "spare. An example would be RAID5 with a spare disk which "
          "would have a PackageRedundancy of 2. Possible values are 0 "
          "to n. The bounds for redundancy are specified using the "
          "properties, PackageRedundancyMax and PackageRedundancyMin."), 
       ModelCorrespondence { 
          "CIM_StorageCapabilities.PackageRedundancyMin",
          "CIM_StorageCapabilities.PackageRedundancyMax" }]
   uint16 PackageRedundancyDefault;

      [Description (
          "DeltaReservatioMax is a number between 1 (1%) and a 100 "
          "(100%) that specifies the maximum amount of space reserved "
          "in a replica for caching changes. For a complete copy this "
          "would be 100%, but it can be lower in some implementations. "
          "This parameter sets the upper limit, while "
          "DeltaReservationMin sets the lower limit."), 
       Units ( "Percentage" ), MinValue ( 0 ), MaxValue ( 100 ), 
       ModelCorrespondence { 
          "CIM_StorageCapabilities.DeltaReservationMin",
          "CIM_StorageCapabilities.DeltaReservationDefault" }]
   uint16 DeltaReservationMax;

      [Description (
          "DeltaReservationMin is a number between 1 (1%) and a 100 "
          "(100%) that specifies the minimum amount of space that "
          "should be reserved in a replica for caching changes. For a "
          "complete copy this would be 100%, but it can be lower in "
          "some implementations. This parameter sets the lower limit, "
          "while DeltaReservationMax sets the upper limit."), 
       Units ( "Percentage" ), MinValue ( 0 ), MaxValue ( 100 ), 
       ModelCorrespondence { 
          "CIM_StorageCapabilities.DeltaReservationMax",
          "CIM_StorageCapabilities.DeltaReservationDefault" }]
   uint16 DeltaReservationMin;

      [Description (
          "Delta reservation is a number between 1 (1%) and a 100 "
          "(100%) that specifies how much space should be reserved by "
          "default in a replica for caching changes. For a complete "
          "copy this would be 100%, but it can be lower in some "
          "implementations. This parameter sets the default value, "
          "while DeletaReservationMax and DeltReservationMin set the "
          "upper and lower bounds."), 
       Units ( "Percentage" ), MinValue ( 0 ), MaxValue ( 100 ), 
       ModelCorrespondence { 
          "CIM_StorageCapabilities.DeltaReservationMax",
          "CIM_StorageCapabilities.DeltaReservationMin" }]
   uint16 DeltaReservationDefault;

      [Description (
          "Method to create and populate a StorageSetting instance "
          "from a StorageCapability instance. This removes the need to "
          "populate default settings and other settings in the context "
          "of each StorageCapabilities (which could be numerous). If "
          "the underlying instrumentation supports the "
          "StorageSettingWithHints subclass, then an instance of that "
          "class will be created instead."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "..", "32768..65535" }, 
       Values { "Success", "Not Supported", "Unspecified Error",
          "Timeout", "Failed", "Invalid Parameter", "DMTF Reserved",
          "Vendor Specific" }]
   uint32 CreateSetting ( 
         [IN, Description (
             "If 'Default' is passed for the CreateDefault parameter, "
             "the Max, Goal, and Min setting attributes are set to the "
             "Default values of the parent StorageCapabilities when "
             "the instance is created. \n"
             "If set to 'Goal' the new StorageSetting attributes are "
             "set to the related attributes of the parent "
             "StorageCapabilities, e.g. Min to Min, Goal to Default, "
             "and Max to Max. \n"
             "\n"
             "This method maybe deprecated in lieu of intrinsics once "
             "limitations in the CIM Operations are addressed."), 
          ValueMap { "2", "3" }, 
          Values { "Default", "Goal" }]
      uint16 SettingType, 
         [IN ( False ), OUT, Description (
             "Reference to the created StorageSetting instance.")]
      CIM_StorageSetting REF NewSetting ); 

      [Experimental, Description (
          "Extent Stripe Length describes the number of underlying "
          "StorageExtents across which data is striped in the common "
          "striping-based storage organizations. This is also known as "
          "the number of 'members' or 'columns'. \n"
          "A NULL value for ExtentStripeLengthDefault indicates that "
          "the system does not support configuration of storage by "
          "specifying Stripe Length. \n"
          "If Extent Stripe Length is supported, and this Capabilities "
          "instance is associated with a pool that was created with a "
          "range of QOS then ExtentStripeLengthDefault represents the "
          "default value. Other available values(such as min, max, and "
          "discrete values) can be determined by using the "
          "'GetSupportedStripeLengths' and "
          "'GetSupportedStripeLengthRange' methods. \n"
          "If Extent Stripe Length is supported and the pool was "
          "created with a single specific QOS, representing a Raid "
          "group, set, or rank, then this property represents the "
          "current/fixed value for the pool, and Extent Stripe Length "
          "is not supported in subsequent creation of elements from "
          "this pool. Consequently, the 'GetSupportedStripeLength' "
          "methods cannot be used, and in a StorageSetting instance "
          "used as a goal when creating or modifying a child element "
          "of the pool, ExtentStripeLengthGoal, ExtentStripeLengthMin, "
          "and ExtentStripeLengthMax MUST be set to NULL."), 
       MinValue ( 1 )]
   uint16 ExtentStripeLengthDefault;

      [Experimental, Description (
          "ParityLayout specifies whether a parity-based storage "
          "organization is using rotated or non-rotated parity. If "
          "this capabilities instance is associated with a pool that "
          "was created with a range of QOS then ParityLayoutDefault "
          "represents the default value. Other available values can be "
          "determined by using the 'GetSupportedParityLayouts' method. "
          "If the pool was created with a single specific QOS, "
          "representing a Raid group, set, or rank, then this property "
          "represents the current/fixed value for the pool, and "
          "ParityLayout is not supported in subsequent creation of "
          "elements from this pool. Consequently, the "
          "'GetSupportedParityLayouts' method cannot be used, and the "
          "ParityLayoutGoal property in StorageSetting instances used "
          "in child element operations on this pool MUST be set to "
          "NULL. A NULL value for ParityLayoutDefault indicates that "
          "the system does not support configuration of storage by "
          "specifying ParityLayout."), 
       ValueMap { "2", "3" }, 
       Values { "Non-Rotated Parity", "Rotated Parity" }]
   uint16 ParityLayoutDefault;

      [Experimental, Description (
          "User Data Stripe Depth describes the number of bytes "
          "forming a strip in common striping-based storage "
          "organizations. The strip is defined as the size of the "
          "portion of a stripe that lies on one extent. Thus, "
          "ExtentStripeLength * UserDataStripeDepth will yield the "
          "size of one stripe of user data. A NULL value for "
          "UserDataStripeDepthDefault indicates that the system does "
          "not support configuration of storage by specifying Stripe "
          "Depth. \n"
          "If User Data Stripe Depth is supported, and this "
          "Capabilities instance is associated with a pool that was "
          "created with a range of QOS then UserDataStripeDepthDefault "
          "represents the default value. Other available values(such "
          "as min, max, and discrete values) can be determined by "
          "using the 'GetSupportedStripeDepths' and "
          "'GetSupportedStripeDepthRange' methods. \n"
          "If User Data Stripe Depth is supported and the pool was "
          "created with a single specific QOS, representing a Raid "
          "group, set, or rank, then this property represents the "
          "current/fixed value for the pool, and User Data Stripe "
          "Depth is not supported in subsequent creation of elements "
          "from this pool. Consequently, the 'GetSupportedStripeDepth' "
          "methods cannot be used, and in a StorageSetting instance "
          "used as a goal when creating or modifying a child element "
          "of the pool, UserDataStripeDepthGoal, UserStripeDepthMin, "
          "and UserDataStripeDepthMax MUST be set to NULL."), 
       Units ( "Bytes" ), MinValue ( 1 )]
   uint64 UserDataStripeDepthDefault;


      [Experimental, Description (
          "For systems that support discrete ExtentStripeLengths for "
          "volume or pool creation, this method can be used to "
          "retrieve a list of supported values. Note that different "
          "implementations may support either the "
          "GetSupportedStripeLengths or the "
          "GetSupportedStripeLengthRange method. Also note that the "
          "advertised sizes may change after the call due to requests "
          "from other clients. If the system only supports a range of "
          "sizes, then the return value will be set to 3."), 
       ValueMap { "0", "1", "2", "3" }, 
       Values { "Method completed OK", "Method not supported",
          "Choices not available for this Capability",
          "Use GetSupportedStripeLengthRange instead" }]
   uint32 GetSupportedStripeLengths ( 
         [IN ( false ), OUT, Description (
             "List of supported ExtentStripeLengths for a Volume/Pool "
             "creation or modification."), 
          ArrayType ( "Indexed" )]
      uint16 StripeLengths[] ); 

      [Experimental, Description (
          "For systems that support a range of ExtentStripeLengths for "
          "volume or pool creation, this method can be used to "
          "retrieve the supported range. Note that different "
          "implementations may support either the "
          "GetSupportedExtentLengths or the "
          "GetSupportedExtentLengthRange method. Also note that the "
          "advertised sizes may change after the call due to requests "
          "from other clients. If the system only supports discrete "
          "values, then the return value will be set to 3."), 
       ValueMap { "0", "1", "2", "3" }, 
       Values { "Method completed OK", "Method not supported",
          "Choices not available for this Capability",
          "Use GetSupportedStripeLengths instead" }]
   uint32 GetSupportedStripeLengthRange ( 
         [IN ( false ), OUT, Description (
             "The minimum ExtentStripeDepth for a volume/pool in "
             "bytes.")]
      uint16 MinimumStripeLength, 
         [IN ( false ), OUT, Description (
             "The maximum ExtentStripeLength for a volume/pool in "
             "bytes.")]
      uint16 MaximumStripeLength, 
         [IN ( false ), OUT, Description (
             "A volume/pool ExtentStripeLength must be a multiple of "
             "this value which is specified in bytes.")]
      uint32 StripeLengthDivisor ); 

      [Description (
          "For systems that support Parity-based storage organizations "
          "for volume or pool creation, this method can be used to the "
          "supported parity layouts."), 
       ValueMap { "0", "1", "2" }, 
       Values { "Method completed OK", "Method not supported",
          "Choice not aavailable for this capability" }]
   uint32 GetSupportedParityLayouts ( 
         [IN ( false ), OUT, Description (
             "List of supported Parity for a Volume/Pool creation or "
             "modification."), 
          ValueMap { "2", "3" }, 
          Values { "Non-Rotated Parity", "Rotated Parity" },
          ArrayType ( "Indexed" )]
      uint16 ParityLayout[] ); 


      [Experimental, Description (
          "For systems that support discrete UserDataStripeDepths for "
          "volume or pool creation, this method can be used to "
          "retrieve a list of supported values. Note that different "
          "implementations may support either the "
          "GetSupportedStripeDepths or the "
          "GetSupportedStripeDepthRange method. If the system only "
          "supports a range of sizes, then the return value will be "
          "set to 2."), 
       ValueMap { "0", "1", "2" }, 
       Values { "Method completed OK", "Method not supported",
          "Use GetSupportedStripeDepthRange instead" }]
   uint32 GetSupportedStripeDepths ( 
         [IN ( false ), OUT, Description (
             "List of supported UserDataStripeDepths for a Volume/Pool "
             "creation or modification."), 
          Units ( "Bytes" ), ArrayType ( "Indexed" )]
      uint64 StripeDepths[] ); 

      [Experimental, Description (
          "For systems that support a range of UserDataStripeDepths "
          "for volume or pool creation, this method can be used to "
          "retrieve the supported range. Note that different "
          "implementations may support either the "
          "GetSupportedStripeDepths or the "
          "GetSupportedStripeDepthRange method. If the system only "
          "supports discrete values, then the return value will be set "
          "to 2."), 
       ValueMap { "0", "1", "2" }, 
       Values { "Method completed OK", "Method not supported",
          "Use GetSupportedStripeDepths instead" }]
   uint32 GetSupportedStripeDepthRange ( 
         [IN ( false ), OUT, Description (
             "The minimum UserDataStripeDepth for a volume/pool in "
             "bytes."), 
          Units ( "Bytes" )]
      uint64 MinimumStripeDepth, 
         [IN ( false ), OUT, Description (
             "The maximum UserDataStripeDepth for a volume/pool in "
             "bytes."), 
          Units ( "Bytes" )]
      uint64 MaximumStripeDepth, 
         [IN ( false ), OUT, Description (
             "A volume/pool UserDataStripeDepth must be a multiple of "
             "this value which is specified in bytes."), 
          Units ( "Bytes" )]
      uint64 StripeDepthDivisor ); 

};

// ==================================================================
// StorageConfigurationService
// ==================================================================
   [Version ( "2.8.1000" ), Description (
       "This service allows the active management of a Storage Server. "
       "It allows jobs to be started for the creation, modification "
       "and deletion of storage objects (StoragePools, StorageVolumes "
       "and LogicalDisks).")]
class CIM_StorageConfigurationService : CIM_Service {

      [Description (
          "Starts a job to create (or modify) a StoragePool. The "
          "StoragePool will be (or must be) scoped to the same System "
          "as this Service. One of the parameters for this method is "
          "Size. As an input parameter, Size specifies the desired "
          "size of the pool. As an output parameter, it specifies the "
          "size achieved. Space is taken from either or both of the "
          "specified input StoragePools and StorageExtents (InPools "
          "and InExtents). The capability requirements that the Pool "
          "must support are defined using the Goal parameter. If the "
          "requested pool size cannot be created, no action will be "
          "taken, the Return Value will be 4097/0x1001, and the output "
          "value of Size will be set to the nearest possible size. If "
          "0 is returned, then the task completed successfully and the "
          "use of ConcreteJob was not required. If the task will take "
          "some time to complete, a ConcreteJob will be created and "
          "its reference returned in the output parameter Job."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6", "..", "4096",
          "4097", "4098..32767", "32768..65535" }, 
       Values { "Job Completed with No Error", "Not Supported",
          "Unknown", "Timeout", "Failed", "Invalid Parameter",
          "In Use", "DMTF Reserved",
          "Method Parameters Checked - Job Started",
          "Size Not Supported", "Method Reserved", "Vendor Specific" }]
   uint32 CreateOrModifyStoragePool ( 
         [IN, Description (
             "A end user relevant name for the pool being created. If "
             "NULL, then a system supplied default name can be used. "
             "The value will be stored in the 'ElementName' property "
             "for the created pool. If not NULL, this parameter will "
             "supply a new name when modifying an existing pool.")]
      string ElementName, 
         [IN ( false ), OUT, Description (
             "Reference to the job (may be null if job completed).")]
      CIM_ConcreteJob REF Job, 
         [IN, Description (
             "Reference to an instance of StorageSetting that defines "
             "the desired capabilities of the StoragePool. If set to a "
             "null value, the default configuration from the source "
             "pool will be used. If not NULL, this parameter will "
             "supply a new Goal setting when modifying an existing "
             "pool.")]
      CIM_StorageSetting REF Goal, 
         [IN, OUT, Description (
             "As an input parameter this specifies the desired pool "
             "size in bytes. As an output parameter this specifies the "
             "size achieved."), 
          Units ( "Bytes" )]
      uint64 Size, 
         [IN, Description (
             "Array of strings containing representations of "
             "references to CIM_StoragePool instances, that are used "
             "to create the Pool or modify the source pools.")]
      string InPools[], 
         [IN, Description (
             "Array of strings containing representations of "
             "references to CIM_StorageExtent instances, that are used "
             "to create the Pool or modify the source extents.")]
      string InExtents[], 
         [IN, OUT, Description (
             "As an input parameter: if null, creates a new "
             "StoragePool. If not null, modifies the referenced Pool. "
             "When returned, it is a reference to the resulting "
             "StoragePool.")]
      CIM_StoragePool REF Pool); 

      [Description (
          "Start a job to create (or modify) a specified element (for "
          "example a StorageVolume or StorageExtent) from a "
          "StoragePool. One of the parameters for this method is Size. "
          "As an input parameter, Size specifies the desired size of "
          "the element. As an output parameter, it specifies the size "
          "achieved. Space is taken from the input StoragePool. The "
          "desired settings for the element are specified by the Goal "
          "parameter. If the requested size cannot be created, no "
          "action will be taken, and the Return Value will be "
          "4097/0x1001. Also, the output value of Size is set to the "
          "nearest possible size. If 0 is returned, the function "
          "completed successfully and no ConcreteJob instance was "
          "required. If 4096/0x1000 is returned, a ConcreteJob will be "
          "started to create the element. The Job's reference will be "
          "returned in the output parameter Job."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6", "..", "4096",
          "4097", "4098..32767", "32768..65535" }, 
       Values { "Job Completed with No Error", "Not Supported",
          "Unknown", "Timeout", "Failed", "Invalid Parameter",
          "In Use", "DMTF Reserved",
          "Method Parameters Checked - Job Started",
          "Size Not Supported", "Method Reserved", "Vendor Specific" }]
   uint32 CreateOrModifyElementFromStoragePool( 
         [IN, Description (
             "A end user relevant name for the element being created. "
             "If NULL, then a system supplied default name can be "
             "used. The value will be stored in the 'ElementName' "
             "property for the created element. If not NULL, this "
             "parameter will supply a new name when modifying an "
             "existing element.")]
      string ElementName, 
         [IN, Description (
             "Enumeration indicating the type of element being created "
             "or modified. If the input parameter TheElement is "
             "specified when the operation is a 'modify', this type "
             "value must match the type of that instance."), 
          ValueMap { "0", "1", "2", "3", "4", "..", "32768..65535" }, 
          Values { "Unknown", "Reserved", "StorageVolume",
             "StorageExtent", "LogicalDisk", "DMTF Reserved",
             "Vendor Specific" }]
      uint16 ElementType, 
         [IN ( false ), OUT, Description (
             "Reference to the job (may be null if job completed).")]
      CIM_ConcreteJob REF Job, 
         [IN, Description (
             "The requirements for the element to maintain. If set to "
             "a null value, the default configuration from the source "
             "pool will be used. This parameter should be a reference "
             "to a Setting or Profile appropriate to the element being "
             "created. If not NULL, this parameter will supply a new "
             "Goal when modifying an existing element.")]
      CIM_ManagedElement REF Goal, 
         [IN, OUT, Description (
             "As an input parameter Size specifies the desired size. "
             "If not NULL, this parameter will supply a new size when "
             "modifying an existing element. As an output parameter "
             "Size specifies the size achieved."), 
          Units ( "Bytes" )]
      uint64 Size, 
         [IN, Description (
             "The Pool from which to create the element. This "
             "parameter must be set to null if the input parameter "
             "TheElement is specified (in the case of a 'modify' "
             "operation).")]
      CIM_StoragePool REF InPool, 
         [IN, OUT, Description (
             "As an input parameter: if null, creates a new element. "
             "If not null, then the method modifies the specified "
             "element. As an output parameter, it is a reference to "
             "the resulting element.")]
      CIM_LogicalElement REF TheElement); 

      [Description (
          "Start a job to delete a StoragePool. The freed space is "
          "returned source StoragePools (indicated by AllocatedFrom "
          "StoragePool) or back to underlying storage extents. If 0 is "
          "returned, the function completed successfully, and no "
          "ConcreteJob was required. If 4096/0x1000 is returned, a "
          "ConcreteJob will be started to delete the StoragePool. A "
          "reference to the Job is returned in the Job parameter."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6", "..", "4096",
          "4097..32767", "32768..65535" }, 
       Values { "Job Completed with No Error", "Not Supported",
          "Unknown", "Timeout", "Failed", "Invalid Parameter",
          "In Use", "DMTF Reserved",
          "Method Parameters Checked - Job Started", "Method Reserved",
          "Vendor Specific" }]
   uint32 DeleteStoragePool ( 
         [IN ( false ), OUT, Description (
             "Reference to the job (may be null if job completed).")]
      CIM_ConcreteJob REF Job, 
         [IN, Description (
             "Reference to the pool to delete.")]
      CIM_StoragePool REF Pool); 

      [Description (
          "Start a job to delete an element previously created from a "
          "StoragePool. The freed space is returned to the source "
          "StoragePool. If 0 is returned, the function completed "
          "successfully and no ConcreteJob was required. If "
          "4096/0x1000 is returned, a ConcreteJob will be started to "
          "delete the element. A reference to the Job is returned in "
          "the Job parameter."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6", "..", "4096",
          "4097..32767", "32768..65535" }, 
       Values { "Job Completed with No Error", "Not Supported",
          "Unknown", "Timeout", "Failed", "Invalid Parameter",
          "In Use", "DMTF Reserved",
          "Method Parameters Checked - Job Started", "Method Reserved",
          "Vendor Specific" }]
   uint32 ReturnToStoragePool( 
         [IN ( false ), OUT, Description (
             "Reference to the job (may be null if job completed).")]
      CIM_ConcreteJob REF Job, 
         [IN, Description (
             "Reference to the element to return to the StoragePool.")]
      CIM_LogicalElement REF TheElement); 

      [Description (
          "Start a job to create a new storage object which is a "
          "replica of the specified source storage object. "
          "(SourceElement). Note that using the input paramter, "
          "CopyType, this function can be used to instantiate the "
          "replica, and to create an ongoing association between the "
          "source and replica. If 0 is returned, the function "
          "completed successfully and no ConcreteJob instance is "
          "created. If 4096/0x1000 is returned, a ConcreteJob is "
          "started, a reference to which is returned in the Job output "
          "parameter."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6", "..", "4096",
          "4097..32767", "32768..65535" }, 
       Values { "Job Completed with No Error", "Not Supported",
          "Unknown", "Timeout", "Failed", "Invalid Parameter",
          "In Use", "DMTF Reserved",
          "Method Parameters Checked - Job Started", "Method Reserved",
          "Vendor Specific" }]
   uint32 CreateReplica( 
         [IN, Description (
             "A end user relevant name for the element being created. "
             "If NULL, then a system supplied default name can be "
             "used. The value will be stored in the 'ElementName' "
             "property for the created element.")]
      string ElementName, 
         [IN ( false ), OUT, Description (
             "Reference to the job (may be null if job completed).")]
      CIM_ConcreteJob REF Job, 
         [Required, IN, Description (
             "The source storage object which may be a StorageVolume "
             "or storage object.")]
      CIM_LogicalElement REF SourceElement, 
         [IN ( false ), OUT, Description (
             "Reference to the created target storage element (i.e., "
             "the replica).")]
      CIM_LogicalElement REF TargetElement, 
         [IN, Description (
             "The definition for the StorageSetting to be maintained "
             "by the target storage object (the replica).")]
      CIM_StorageSetting REF TargetSettingGoal, 
         [IN, Description (
             "The underlying storage for the target element (the "
             "replica) will be drawn from TargetPool if specified, "
             "otherwise the allocation is implementation specific.")]
      CIM_StoragePool REF TargetPool, 
         [IN, Description (
             "CopyType describes the type of copy that will be made. "
             "Values are: \n"
             "Async: Create and maintain an asynchronous copy of the "
             "source. \n"
             "Sync: Create and maintain a synchronized copy of the "
             "source. \n"
             "UnSyncAssoc: Create an unsynchronized copy and maintain "
             "an association to the source. \n"
             "UnSyncUnAssoc: Create unassociated copy of the source "
             "element."), 
          ValueMap { "2", "3", "4", "5", "..", "32768..65535" }, 
          Values { "Async", "Sync", "UnSyncAssoc", "UnSyncUnAssoc",
             "DMTF Reserved", "Vendor Specific" }]
      uint16 CopyType); 

      [Description (
          "Modify (or start a job to modify) the synchronization "
          "association between two storage objects. If 0 is returned, "
          "the function completed successfully and no ConcreteJob "
          "instance was created. If 0x1000 is returned, a ConcreteJob "
          "was started and a reference to this Job is returned in the "
          "Job output parameter. A return value of 1 indicates the "
          "method is not supported. All other values indicate some "
          "type of error condition."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6", "..", "0x1000",
          "0x1001..0x7FFF", "0x8000..0xFFFF" }, 
       Values { "Job Completed with No Error", "Not Supported",
          "Unspecified Error", "Timeout", "Failed",
          "Invalid Parameter", "In Use", "DMTF Reserved",
          "Method Parameters Checked - Job Started", "Method Reserved",
          "Vendor Specific" }]
   uint32 ModifySynchronization( 
         [IN, Description (
             "Operation describes the type of modification to be made "
             "to the replica. Values are: \n"
             "Detach: 'Forget' the synchronization between two storage "
             "objects. Start to treat the objects as independent. \n"
             "Fracture: Suspend the synchronization between two "
             "storage objects. The association and (typically) changes "
             "are remembered to allow a fast resynchronization. This "
             "may be used during a backup cycle to allow one of the "
             "objects to be copied while the other remains in "
             "production. \n"
             "Resync Replica: Re-establish the synchronization of a "
             "replica. This will negate the action of a previous "
             "Fracture operation. \n"
             "Restore from Replica: Renew the contents of the original "
             "storage object from a replica. \n"
             "Prepare: Get the link ready for a Resync operation to "
             "take place. Some implementations will require this "
             "operation to be invoked to keep the Resync operation as "
             "fast as possible. \n"
             "Unprepare: Clear a prepared state if a Prepare is not to "
             "be followed by a Resync operation. \n"
             "Quiesce: Some applications require notification so that "
             "they can ready the link for an operation. For example "
             "flush any cached data or buffered changes. \n"
             "Unquiesce: Take the link from the quiesced state "
             "(without executing the intended operation. \n"
             "Reset To Sync: Change the CopyType of the association to "
             "Sync (e.g., from the Async CopyType). \n"
             "Reset To Async: Change the CopyType of the association "
             "to Async (e.g., from the Sync CopyType)."), 
          ValueMap { "0","1","2", "3", "4", "5", "6", "7", "8", "9",
             "10", "11", "..", "0x8000..0xFFFF" }, 
          Values { "DMTF Reserved", "DMTF Reserved", "Detach",
             "Fracture", "Resync Replica", "Restore from Replica",
             "Prepare", "Unprepare", "Quiesce", "Unquiesce",
             "Reset To Sync", "Reset To Async", "DMTF Reserved",
             "Vendor Specific" }]
      uint16 Operation, 
         [IN ( false ), OUT, Description (
             "Reference to the job (may be null if the task "
             "completed).")]
      CIM_ConcreteJob REF Job, 
         [IN, Description (
             "The referenced to the StorageSynchronized association "
             "describing the storage source/replica relationship.")]
      CIM_StorageSynchronized REF Synchronization); 

      [Description (
          "Create (or start a job to create) a StorageSynchronized "
          "relationship between two existing storage objects. Note "
          "that using the input parameter, CopyType, this function can "
          "be used to to create an ongoing association between the "
          "source and replica. If 0 is returned, the function "
          "completed successfully and no ConcreteJob instance is "
          "created. If 0x1000 is returned, a ConcreteJob is started, a "
          "reference to which is returned in the Job output parameter. "
          "A return value of 1 indicates the method is not supported. "
          "All other values indicate some type of error condition."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6", "..", "0x1000",
          "0x1001..0x7FFF", "0x8000..0xFFFF" }, 
       Values { "Job Completed with No Error", "Not Supported",
          "Unspecified Error", "Timeout", "Failed",
          "Invalid Parameter", "In Use", "DMTF Reserved",
          "Method Parameters Checked - Job Started", "Method Reserved",
          "Vendor Specific" }]
   uint32 AttachReplica( 
         [IN ( false ), OUT, Description (
             "Reference to the job (may be null if the task "
             "completed).")]
      CIM_ConcreteJob REF Job, 
         [Required, IN, Description (
             "The source storage object which may be a StorageVolume "
             "or other storage object.")]
      CIM_ManagedElement REF SourceElement, 
         [IN, Description (
             "Reference to the target storage element (i.e., the "
             "replica).")]
      CIM_ManagedElement REF TargetElement, 
         [IN, Description (
             "CopyType describes the type of Synchronized relationship "
             "that will be created. Values are: \n"
             "Async: Create and maintain an asynchronous copy of the "
             "source. \n"
             "Sync: Create and maintain a synchronized copy of the "
             "source. \n"
             "UnSyncAssoc: Create an unsynchronized copy and maintain "
             "an association to the source. \n"
             "UnSyncUnAssoc: Create unassociated copy of the source "
             "element."), 
          ValueMap { "2", "3", "4", "5", "..", "0x8000..0xFFFF" }, 
          Values { "Async", "Sync", "UnSyncAssoc", "UnSyncUnAssoc",
             "DMTF Reserved", "Vendor Specific" }]
      uint16 CopyType); 

      [Experimental, Description (
          "Start a job to create (or modify) a specified storage "
          "element from specified input StorageExtents. The created or "
          "modified storage element can be a StorageExtent, "
          "StorageVolume, LogicalDisk, or StoragePool. An input list "
          "of InElements must be specified. The GetAvailableExtents "
          "method can be used to get a list of valid extents that can "
          "be used to achieve a desired goal. Validity of the extents "
          "is determined by the implementation. As an input parameter, "
          "Size specifies the desired size of the element. As an "
          "output parameter, it specifies the size achieved. Space is "
          "taken from the input InElements. The desired Settings for "
          "the element are specified by the Goal parameter. If the "
          "size of Extents passed is less than the size requested, "
          "then the capacity is drawn from the extents in the order, "
          "left to right, that the Extents were specified. The partial "
          "consumption of an Extent is represented by an Extent for "
          "the capacity used and an Extent for the capacity not used. "
          "If the Size is NULL, then a configuration using all Extents "
          "passed will be attempted. If the requested size cannot be "
          "created, no action will be taken, and the Return Value will "
          "be 4097/0x1001. Also, the output value of Size is set to "
          "the nearest possible size. If 0 is returned, the function "
          "completed successfully and no ConcreteJob instance was "
          "required. If 4096/0x1000 is returned, a ConcreteJob will be "
          "started to create the element. The Job's reference will be "
          "returned in the output parameter Job."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6", "..", "4096",
          "4097", "4098..32767", "32768..65535" }, 
       Values { "Completed with No Error", "Not Supported", "Unknown",
          "Timeout", "Failed", "Invalid Parameter", "In Use",
          "DMTF Reserved", "Method Parameters Checked - Job Started",
          "Size Not Supported", "Method Reserved", "Vendor Specific" }]
   uint32 CreateOrModifyElementFromElements( 
         [IN, Description (
             "A end user relevant name for the element being created. "
             "If NULL, then a system-supplied default name can be "
             "used. The value will be stored in the 'ElementName' "
             "property for the created element. If not NULL, this "
             "parameter will supply a new name when modifying an "
             "existing element.")]
      string ElementName, 
         [Required, IN, Description (
             "Enumeration indicating the type of element being created "
             "or modified. If the input parameter TheElement is "
             "specified when the operation is a 'modify', this type "
             "value must match the type of that instance. The actual "
             "CIM class of the created TheElement can be "
             "vendor-specific, but it must be a derived class of the "
             "appropriate CIM class -- i.e., CIM_StorageVolume, "
             "CIM_StorageExtent, CIM_LogicalDisk, or CIM_StoragePool."), 
          ValueMap { "0", "1", "2", "3", "4", "5", "..",
          "32768..65535" }, 
          Values { "Unknown", "Reserved", "Storage Volume",
             "Storage Extent", "Storage Pool", "Logical Disk",
             "DMTF Reserved", "Vendor Specific" }]
      uint16 ElementType, 
         [IN ( false ), OUT, Description (
             "Reference to the job (may be null if job completed).")]
      CIM_ConcreteJob REF Job, 
         [Required, IN, Description (
             "The requirements for the element to maintain. If set to "
             "a null value, the default configuration associated with "
             "the Service will be used. This parameter should be a "
             "reference to a Setting, SettingData, or Profile "
             "appropriate to the element being created. If not NULL, "
             "this parameter will supply a new Goal when modifying an "
             "existing element.")]
      CIM_ManagedElement REF Goal, 
         [IN, OUT, Description (
             "As an input parameter Size specifies the desired size. "
             "If not NULL, this parameter will supply a new size when "
             "modifying an existing element. As an output parameter "
             "Size specifies the size achieved."), 
          Units ( "Bytes" )]
      uint64 Size, 
         [Required, IN, Description (
             "Array of references to storage element instances that "
             "are used to create or modify TheElement.")]
      CIM_StorageExtent REF InElements[], 
         [IN, OUT, Description (
             "As an input parameter: if null, creates a new element. "
             "If not null, then the method modifies the specified "
             "element. As an output parameter, it is a reference to "
             "the resulting element.")]
      CIM_LogicalElement REF TheElement); 

      [Experimental, Description (
          "This method requests that the system rescan SCSI devices "
          "for changes in their configuration. If called on a "
          "general-purpose host, the changes are reflected in the list "
          "of devices available to applications (for example, the UNIX "
          "'device tree'. This method may also be used on a storage "
          "appliance to force rescanning of attached SCSI devices. \n"
          "\n"
          "This operation can be disruptive; optional parameters allow "
          "the caller to limit the scan to a single or set of SCSI "
          "device elements. All parameters are optional; if parameters "
          "other Job are passed in as null, a full scan is invoked."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6..4095", "4096",
          "4097", "4098", "4099", "4100", "..", "32768..65535" }, 
       Values { "Success", "Not Supported", "Unknown", "Timeout",
          "Failed", "Invalid Parameter", "DMTF Reserved",
          "Invalid connection type", "Invalid Initiator",
          "No matching target found", "No matching LUs found",
          "Prohibited by name binding configuration", "DMTF Reserved",
          "Vendor Specific" }]
   uint32 ScsiScan ( 
         [IN, OUT, Description (
             "Reference to the job (may be null if job completed).")]
      CIM_ConcreteJob REF Job,
      
         [Description (
             "The type of connection, constrains the scan to initiator "
             "ports of this type. Only used if the Initiators "
             "parameter is null."), 
          ValueMap { "1", "2", "3", "4", "5", "6", "7", "8", "9" }, 
          Values { "Other", "Fibre Channel", "Parallel SCSI", "SSA",
             "IEEE 1394", "RDMA", "iSCSI", "SAS", "ADT" }, 
          ModelCorrespondence { 
             "CIM_SCSIProtocolEndpoint.ConnectionType" }]
      uint16 ConnectionType,
      
         [Description (
             "The connection type, if the ConnectionType parameter is "
             "\"Other\".")]
      string OtherConnectionType,
      
         [Description (
             "A list of references to initiators. Scanning will be "
             "limited to SCSI targets attached to these initiators. If "
             "this parameter is null and connection is specified, all "
             "initiators of that connection type are scanned. If this "
             "parameter and ConnectionType are null, all targets on "
             "all system initiators are probed.")]
      CIM_SCSIProtocolEndpoint REF Initiators[],
      
         [Description (
             "A list of names or numbers for targets. These should be "
             "formatted to match the appropriate connection type, For "
             "example, PortWWNs would be specified for Fibre Channel "
             "targets.")]
      string Targets[],
      
         [Description (
             "A list of SCSI logical unit numbers representing logical "
             "units hosted on the targets specified in the Targets "
             "argument.")]
      string LogicalUnits[]); 
};

// ==================================================================
//  StorageConfigurationCapabilities
// ==================================================================
   [Version ( "2.8.1000" ), Description (
       "A subclass of Capabilities that defines the Capabilities of a "
       "StorageConfigurationService. An instance of "
       "StorageConfigurationCapabilities is associated with a "
       "StorageConfigurationService using ElementCapabilities. The "
       "properties in this class specify the envelope of capabilites "
       "for storage configuration in the context of the Service or "
       "Pool with which the instance is associated. These properties "
       "correspond to the properties of the same base names in "
       "StorageSetting and StorageSettingWithHints when either is used "
       "as a goal parameter to the StorageConfigurationService methods "
       "(CreateOrModifyStoragePool, "
       "CreateOrModifyElementFromStoragePool, or "
       "CreateOrModifyElementFromElements).")]
class CIM_StorageConfigurationCapabilities : CIM_Capabilities {

      [Description (
          "Enumeration indicating what operations will be executed as "
          "asynchronous jobs. If an operation is included in both this "
          "and SupportedSynchronousActions then the underlying "
          "implementation is indicating that it may or may not create "
          "a job."), 
       ValueMap { "2", "3", "4", "5", "6", "7", "8", "9", "10" }, 
       Values { "Storage Pool Creation", "Storage Pool Deletion",
          "Storage Pool Modification", "Storage Element Creation",
          "Storage Element Return", "Storage Element Modification",
          "Replica Creation", "Replica Modification",
          "Replica Attachment" }, 
       ModelCorrespondence { 
          "CIM_StorageConfigurationCapabilities.SupportedSynchronousActions" 
          }]
   uint16 SupportedAsynchronousActions[];

      [Description (
          "Enumeration indicating what operations will be executed "
          "without the creation of a job. If an operation is included "
          "in both this and SupportedAsynchronousActions then the "
          "underlying instrumentation is indicating that it may or may "
          "not create a job."), 
       ValueMap { "2", "3", "4", "5", "6", "7", "8", "9", "10" }, 
       Values { "Storage Pool Creation", "Storage Pool Deletion",
          "Storage Pool Modification", "Storage Element Creation",
          "Storage Element Return", "Storage Element Modification",
          "Replica Creation", "Replica Modification",
          "Replica Attachment" }, 
       ModelCorrespondence { "CIM_StorageConfigurationCapabilities." 
          "SupportedAsynchronousActions" }]
   uint16 SupportedSynchronousActions[];

      [Description (
          "Enumeration indicating the type of storage elements that "
          "are supported by the associated "
          "StorageConfigurationService."), 
       ValueMap { "2", "3", "4", "..", "0x8000..0xFFFF" }, 
       Values { "StorageVolume", "StorageExtent", "LogicalDisk",
          "DMTF Reserved", "Vendor Specific" }, 
       ModelCorrespondence { "CIM_StorageConfigurationService." 
          "CreateOrModifyElementFromStoragePool.ElementType" }]
   uint16 SupportedStorageElementTypes[];

      [Description (
          "Enumeration indicating features supported by the "
          "StoragePool methods."), 
       ValueMap { "2", "3", "4", "..", "0x8000..0xFFFF" }, 
       Values { "InExtents", "Single InPool", "Multiple InPools",
          "DMTF Reserved", "Vendor Specific" }, 
       ModelCorrespondence { "CIM_StorageConfigurationService." 
          "CreateOrModifyStoragePool.InPools",
          "CIM_StorageConfigurationService." 
          "CreateOrModifyStoragePool.InExtents" }]
   uint16 SupportedStoragePoolFeatures[];

      [Description (
          "Enumeration indicating features supported by the Storage "
          "Element methods."), 
       ValueMap { "2", "3", "4", "5", "6", "7", "8", "9", "10", "..",
          "0x8000..0xFFFF" }, 
       Values { "StorageExtent Creation", "StorageVolume Creation",
          "StorageExtent Modification", "StorageVolume Modification",
          "Single InPool", "Multiple InPools", "LogicalDisk Creation",
          "LogicalDisk Modification", "InExtents", "DMTF Reserved",
          "Vendor Specific" }, 
       ModelCorrespondence { "CIM_StorageConfigurationService." 
          "CreateOrModifyElementFromStoragePool.ElementType",
          "CIM_StorageConfigurationService." 
          "CreateOrModifyElementFromStoragePool.InPool",
          "CIM_StorageConfigurationService." 
          "CreateOrModifyElementFromElements.InElements" }]
   uint16 SupportedStorageElementFeatures[];

      [Description (
          "SupportedCopyTypes describes the replication capabilities "
          "supported by the associated StorageConfigurationServices. "
          "Values are: \n"
          "Async: asynchronous copies may be created and maintained. \n"
          "Sync: synchronous copies may be created and maintained. \n"
          "UnSyncAssoc: unsynchronized copies may be created and "
          "maintained. \n"
          "UnSyncUnAssoc: a 'straight copy' may be created."), 
       ValueMap { "2", "3", "4", "5", "..", "0x8000..0xFFFF" }, 
       Values { "Async", "Sync", "UnSyncAssoc", "UnSyncUnAssoc",
          "DMTF Reserved", "Vendor Specific" }, 
       ModelCorrespondence { 
          "CIM_StorageConfigurationService.CreateReplica.CopyType" }]
   uint16 SupportedCopyTypes[];

      [Description (
          "InitialReplicationState specifies which initial "
          "ReplicationState is supported by a particular provider. "
          "Values are: \n"
          "Initialized: The replication relationship is known and "
          "unsynchronized, but time required to synchronize may be "
          "long. \n"
          "Prepared: The replication relationship is known and "
          "unsynchronized and the time required to synchronize will be "
          "short. \n"
          "Synchronized: The replicas are synchronized."), 
       ValueMap { "2", "3", "4", "..", "0x8000..0xFFFF" }, 
       Values { "Initialized", "Prepared", "Synchronized",
          "DMTF Reserved", "Vendor Specific" }, 
       ModelCorrespondence { 
          "CIM_StorageConfigurationService.AttachReplica",
          "CIM_StorageConfigurationService.CreateReplica" }]
   uint16 InitialReplicationState;

};

// ====================================================================
// StorageSettingWithHints
// ====================================================================
   [Version ( "2.7.1" ), Description (
       "This subclass of StorageSetting allows a client to specify "
       "'hint's for optimization of the volume performance. The effect "
       "of these hints is implementation dependent.")]
class CIM_StorageSettingWithHints : CIM_StorageSetting {

      [Write, Description (
          "This hint is an indication from a client of the importance "
          "placed on data availability. Values are 0=Don't Care to "
          "10=Very Important."), 
       MinValue ( 0 ), MaxValue ( 10 )]
   uint16 DataAvailabilityHint;

      [Write, Description (
          "This hint is an indication from a client of the randomness "
          "of accesses. Values are 0=Entirely Sequential to "
          "10=Entirely Random."), 
       MinValue ( 0 ), MaxValue ( 10 )]
   uint16 AccessRandomnessHint;

      [Write, Description (
          "This hint is an indication from a client of the direction "
          "of accesses. Values are 0=Entirely Read to 10=Entirely "
          "Write."), 
       MinValue ( 0 ), MaxValue ( 10 )]
   uint16 AccessDirectionHint;

      [Write, Description (
          "This hint is an indication from a client of the optimal "
          "access sizes (in bytes). Since this property is an array, "
          "several sizes can be specified."), 
       Units ( "Bytes" )]
   uint16 AccessSizeHint[];

      [Write, Description (
          "This hint is an indication from a client how important "
          "access latency is. Values are 0=Don't Care to 10=Very "
          "Important."), 
       MinValue ( 0 ), MaxValue ( 10 )]
   uint16 AccessLatencyHint;

      [Write, Description (
          "This hint is an indication from a client of bandwidth "
          "prioritization. Values are 0=Don't Care to 10=Very "
          "Important."), 
       MinValue ( 0 ), MaxValue ( 10 )]
   uint16 AccessBandwidthWeight;

      [Write, Description (
          "This hint is an indication of the importance the client "
          "places on the cost of storage. Values are 0=Don't Care to "
          "10=Very Important. A StorageVolume provider might choose to "
          "place data on low cost or high cost drives based on this "
          "parameter."), 
       MinValue ( 0 ), MaxValue ( 10 )]
   uint16 StorageCostHint;

      [Write, Description (
          "This hint is an indication of the importance placed on "
          "storage space efficiency by the client. Values are 0=Don't "
          "Care to 10=Very Important. A StorageVolume provider might "
          "choose different RAID levels based on this hint."), 
       MinValue ( 0 ), MaxValue ( 10 )]
   uint16 StorageEfficiencyHint;
};


// ===================================================================
// AllocatedFromStoragePool
// ===================================================================
   [Association, Version ( "2.8.0" ), Description (
       "AllocatedFromStoragePool is an association describing how "
       "LogicalElements are allocated from underlying StoragePools. "
       "These elements typically would be subclasses of StorageExtents "
       "or StoragePools.")]
class CIM_AllocatedFromStoragePool : CIM_Dependency {

      [Override ( "Antecedent" ), Description (
          "The StoragePool.")]
   CIM_StoragePool REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The subsidiary element.")]
   CIM_LogicalElement REF Dependent;

      [Required, Description (
          "Space consumed from this Pool, in bytes. This value MUST be "
          "maintained so that, relative to the Antecedent StoragePool, "
          "it is possible to compute TotalManagedSpace as "
          "StoragePool.RemainingManagedSpace plus the sum of "
          "SpaceConsumed from all of the AllocatedFromStoragePool "
          "references from the antecedent StoragePool."), 
       Units ( "Bytes" ), 
       ModelCorrespondence { "CIM_StoragePool.TotalManagedSpace",
          "CIM_StoragePool.RemainingManagedSpace" }]
   uint64 SpaceConsumed;

};


// ==================================================================
// HostedStoragePool
// ==================================================================
   [Association, Aggregation, Composition, Version ( "2.7.0" ), 
    Description (
       "SystemStoragePool is a specialization of SystemComponent "
       "association that establishes that the StoragePool is defined "
       "in the context of the System.")]
class CIM_HostedStoragePool : CIM_SystemComponent {

      [Aggregate, Override ( "GroupComponent" ), Min ( 1 ), Max ( 1 ), 
       Description (
          "The parent system in the Association.")]
   CIM_System REF GroupComponent;

      [Override ( "PartComponent" ), Description (
          "The StoragePool that is a component of a System.")]
   CIM_StoragePool REF PartComponent;
};


// ===================================================================
// ConfigurationReportingService
// ===================================================================
   [Version ( "2.7.0" ), Description (
       "Service to provide reports on current configuration and "
       "potential for growth. The service may be used in several "
       "circumstances: \n"
       "- To report growth potential (how many can I have) \n"
       "- To report information on objects not directly modeled for "
       "performance or other reasons. \n"
       "It can also report counts of 'things' or counts of 'units'. "
       "For example, the number of disk drives could be reported or "
       "the capacity that they would provide.")]
class CIM_ConfigurationReportingService : CIM_Service {

      [Description (
          "Returns a list of classes that the given Managed Element "
          "supports or has installed."), 
       ValueMap { "0", "1", "2", "3", "4", "..", "32768..65535" }, 
       Values { "Success", "Not Supported", "Unknown", "Timeout",
          "Failed", "DMTF Reserved", "Vendor Specific" }]
   uint32 GetClassTypes( 
         [IN, Description (
             "The type of inquiry to be performed."), 
          ValueMap { "2", "3" }, 
          Values { "Supports", "Installed" }]
      uint16 InquiryType, 
         [IN, Description (
             "False : Only report on elements directly contained "
             "in/attached to the given ManagedElement. \n"
             "True : Report on all objects contained in/attached to "
             "the given ManagedElement.")]
      boolean Recursive, 
         [IN, Description (
             "The target of query, for example a rack or a chassis.")]
      CIM_ManagedElement REF Target, 
         [IN ( false ), OUT, Description (
             "Array containing the class names (typically the leaf "
             "classes) that the given ManagedElement can support or "
             "has installed.")]
      string ClassTypes[]); 

      [Description (
          "Returns a list of UnitTypes that are installed for a given "
          "ClassType on a given ManagedElement."), 
       ValueMap { "0", "1", "2", "3", "4", "..", "32768..65535" }, 
       Values { "Success", "Not Supported", "Unknown", "Timeout",
          "Failed", "DMTF Reserved", "Vendor Specific" }]
   uint32 GetUnitTypes( 
         [IN, Description (
             "The type of inquiry to be performed."), 
          ValueMap { "2", "3" }, 
          Values { "Supported", "Installed" }]
      uint16 InquiryType, 
         [IN, Description (
             "False : Only report on elements directly contained "
             "in/attached to the given ManagedElement. \n"
             "True : Report on all objects contained in/attached to "
             "the given ManagedElement.")]
      boolean Recursive, 
         [IN, Description (
             "The target of query, for example a rack or a chassis.")]
      CIM_ManagedElement REF Target, 
         [IN, Description (
             "The ClassType for the query. This should be a entry "
             "returned in the GetClassTypes.ClassTypes property.")]
      string ClassType, 
         [IN ( false ), OUT, Description (
             "A list of supported UnitTypes."), 
          ValueMap { "2", "3", "4", "5", "6", "7", "8", "9", "10",
             "..", "32768..65535" }, 
          Values { "None", "Front Side", "Back Side", "Contained",
             "Connected", "I/O", "Memory", "StorageMediaLocation",
             "Megabytes", "DMTF Reserved", "Vendor Specific" }, 
          ModelCorrespondence { "CIM_ConfigurationReportingService." 
             "ReportCapacity(UnitType)" }]
      uint16 UnitTypes[]); 

      [Description (
          "Returns the maximum number supported or the number of "
          "currently installed units for the given UnitType, for a "
          "given ClassType on a given ManagedElement."), 
       ValueMap { "0", "1", "2", "3", "4", "..", "32768..65535" }, 
       Values { "Success", "Not Supported", "Unknown", "Timeout",
          "Failed", "DMTF Reserved", "Vendor Specific" }]
   uint32 ReportCapacity( 
         [IN, Description (
             "The type of inquiry to be performed."), 
          ValueMap { "2", "3" }, 
          Values { "Supported", "Installed" }]
      uint16 InquiryType, 
         [IN, Description (
             "False : Only report on elements directly contained "
             "in/attached to the given ManagedElement. \n"
             "True : Report on all objects contained in/attached to "
             "the given ManagedElement.")]
      boolean Recursive, 
         [IN, Description (
             "The target of query, for example a rack or a chassis.")]
      CIM_ManagedElement REF Target, 
         [IN, Description (
             "The ClassType for the query. This should be a entry "
             "returned in the GetClassTypes.ClassTypes property.")]
      string ClassType, 
         [IN, Description (
             "The UnitType for the query."), 
          ValueMap { "2", "3", "4", "5", "6", "7", "8", "9", "10",
             "..", "32768..65535" }, 
          Values { "None", "Front Side", "Back Side", "Contained",
             "Connected", "I/O", "Memory", "StorageMediaLocation",
             "Megabytes", "DMTF Reserved", "Vendor Specific" }, 
          ModelCorrespondence { "CIM_ConfigurationReportingService." 
             "GetUnitTypes(UnitTypes)" }]
      uint16 UnitType, 
         [IN ( false ), OUT, Description (
             "The maximum number of supported or the number of "
             "currently installed units.")]
      uint64 NumberOfUnits); 
};

// ===================================================================
// StorageSettingsAssociatedToCapabilities
// ===================================================================
   [Association, Experimental, Version ( "2.8.1000" ), Description (
       "This association define StorageSettings that reflect the "
       "capabilities of the associated StorageCapabilities. The "
       "associated StorageSetting MAY NOT define the operational "
       "characteristics (through settings properties) of any storage "
       "element. Certain StorageSetting instances can be defined as "
       "\"Fixed = Not Changeable\" by using the \"ChangeableType\" "
       "attribute. \"Fixed\" settings have this special association. "
       "This association SHALL be defined between \"Fixed - Not "
       "Changeable\" instances of StorageSetting with the "
       "StorageCapabilities instances that are associated with the "
       "StoragePools which support the storage characteristics "
       "described by the StorageSetting instance. \n"
       "Fixed settings MAY be associated to many StorageCapabilities.")]
class CIM_StorageSettingsAssociatedToCapabilities : CIM_Dependency {

      [Override ( "Antecedent" ), Description (
          "The StorageCapabilities.")]
   CIM_StorageCapabilities REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The StorageSetting.")]
   CIM_StorageSetting REF Dependent;

      [Required, Description (
          "The default association associates the setting that will be "
          "used to create or modify a Storage Element if a no setting "
          "is passed as a Goal. \n"
          "There MUST be only one default Setting per pool.")]
   boolean DefaultSetting = FALSE;

};


// ===================================================================
// StorageSettingsGeneratedFromCapabilities
// ===================================================================
   [Association, Experimental, Version ( "2.8.1000" ), Description (
       "This association define StorageSettings that reflect the "
       "capabilities of the associated StorageCapabilities. The "
       "associated StorageSetting MAY NOT define the operational "
       "characteristics (through settings properties) of any storage "
       "element. StorageSettingsGeneratedFromCapabilities is the "
       "association between instances of StorageCapabilities and those "
       "instances of StorageSetting that have been created from the "
       "StorageCapabilities instance using the StorageCapabilities "
       "\"CreateSetting\" method. These settings are either "
       "\"Changeable - Transient\" or \"Changeable - Persistent\" The "
       "settings associated by this class reflect the capabilities "
       "from which they are generated. These setting SHALL be "
       "associated with one StorageCapabilities. \n"
       "A generated setting can be deleted by the implementation at "
       "any time if the it is a \"Changed - Transient\" setting. \n"
       "A client SHOULD not use this association to find transient "
       "Settings to subsequently modify and/or use because that would "
       "increase the likelihood of setting contention across clients. "
       "Instead the implementation uses this association to define "
       "transient settings, which can be located through any means, "
       "that have special temporal based life cycle.")]
class CIM_StorageSettingsGeneratedFromCapabilities : CIM_Dependency {

      [Override ( "Antecedent" ), Max ( 1 ), Description (
          "The StorageCapabilities.")]
   CIM_StorageCapabilities REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The StorageSetting.")]
   CIM_StorageSetting REF Dependent;
};

// ===================================================================
// end of file
// ===================================================================
