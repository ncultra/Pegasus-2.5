// ===================================================================
// Title:  Network MPLS
// $State: Exp $
// $Date: 2005/02/24 20:05:58 $
// $Source: /cvs/MSB/pegasus/Schemas/CIMPrelim291/Network_MPLS.mof,v $
// $Revision: 1.1 $
// ===================================================================
//#pragma inLine ("Includes/copyright.inc")
// Copyright 1998-2005 Distributed Management Task Force, Inc. (DMTF).
// All rights reserved.
// DMTF is a not-for-profit association of industry members dedicated
// to promoting enterprise and systems management and interoperability.
// DMTF specifications and documents may be reproduced for uses
// consistent with this purpose by members and non-members,
// provided that correct attribution is given.
// As DMTF specifications may be revised from time to time,
// the particular version and release date should always be noted.
// 
// Implementation of certain elements of this standard or proposed
// standard may be subject to third party patent rights, including
// provisional patent rights (herein "patent rights"). DMTF makes
// no representations to users of the standard as to the existence
// of such rights, and is not responsible to recognize, disclose, or
// identify any or all such third party patent right, owners or
// claimants, nor for any incomplete or inaccurate identification or
// disclosure of such rights, owners or claimants. DMTF shall have no
// liability to any party, in any manner or circumstance, under any
// legal theory whatsoever, for failure to recognize, disclose, or
// identify any such third party patent rights, or for such party's
// reliance on the standard or incorporation thereof in its product,
// protocols or testing procedures. DMTF shall have no liability to
// any party implementing such standard, whether such implementation
// is foreseeable or not, nor to any patent owner or claimant, and shall
// have no liability or responsibility for costs or losses incurred if
// a standard is withdrawn or modified after publication, and shall be
// indemnified and held harmless by any party implementing the
// standard from any and all claims of infringement by a patent owner
// for such implementations.
// 
// For information about patents held by third-parties which have
// notified the DMTF that, in their opinion, such patent may relate to
// or impact implementations of DMTF standards, visit
// http://www.dmtf.org/about/policies/disclosures.php.
//#pragma inLine
// ===================================================================
// Description: The Network Model extends the management concepts to
//              represent protocol interfaces and network/protocol
//              services.  This file defines concepts in support of
//              managing MPLS (Multi-Protocol Label Switching).
// 
//              The object classes below are listed in an order that
//              avoids forward references. Required objects, defined
//              by other working groups, are omitted.
// ==================================================================
// Change Log for v2.9 Preliminary - re-introduce MPLS classes
// 
// Change Log for v2.8 Preliminary
// CR1061 - Add the MPLS Sub-Model that was removed from 2.7 Final.
// CR1128 - Change subclassing from CIM_Dependency to
//          CIM_HostedDependency for identified classes. This is
//          needed as a result of the introduction of HostedDependency
//          by SysDev
// 
// Change Log for v2.7.1
// CR920 - Add missing parenthesis to the Description for MPLSTunnel.
//         IncludeAnyAffinity
// 
// Change Log for v2.7
// CR790 - Add classes to support MPLS
// CR805 - Add MPLSSpecifiedRoute, MPLSSpecifiedNextHop,
//         MPSLComputedNextHop, and RouteSpecifiedForLSP
// CR853 - MPLS Model changes: MPLSQoSPRTrfcProf should subclass from
//         SettingData and several property names are updated in
//         MPLSSegmentStats
// CR905 - MPLS cleanup and updates
//         Add - MPLSTunnel, MPLSReverseDirectionTunnel,
//          MPLSTunnelHops, MPLSNextTunnelHop,
//          MPLSFecOfTunnel and MPLSTunnelStats
//         Remove - MPLSSpecifiedRoute, MPLSSpecifedNextHop,
//          MPLSComputedNextHop, RouteSpecifiedForLSP,
//          MPLSLSPTunnel, MPLSTrafficTrunk,
//          MPLSFecOfTrafficTrunk, MPLSFecOfLSP
//          and MPLSBiDirectionalTrunks
// CR907 - MPLS cleanup and updates
//         Add - MPLSTunnelHop and HostedMPLSTunnelHop
//         Rename MPLSTunnelHops to MPLSHopInTunnel
//         Rename MPLSNextTunnelHop to MPLSNextHopInTunnel
//         Change reference from MPLSTrafficTrunk to MPLSTunnel
//          in MPLSCurrentlyAssignedLSP and MPLSBackupLSP
//         Rename MPLSTunnel.TunnelingSignalingProtocol to
//          TunnelSignalingProtocol
//         Remove .IsPinned, .LocalProtectionAvailable, .IsAdaptive,
//          and .IsDynamicallyRouted properties from MPLSLSP
//         Promote properties of MPLSTEService to MPLSService,
//          and remove MPLSTEService
//         Rename MPLSTunnelStats.MPLSTunnelStateTransitions to
//          TunnelStateTransitions
// 
// ===================================================================

#pragma Locale ("en_US")

// ==================================================================
// MPLSService
// ==================================================================
   [Experimental, Version ( "2.8.1000" ), Description (
       "This object class contains properties relating to the overall "
       "operation of MPLS on a router. This service is weak to the "
       "router (modeled as a ComputerSystem) via the association "
       "CIM_HostedService.")]
class CIM_MPLSService : CIM_Service {

      [Description (
          "Path computation may be configured to be more or less "
          "reactive to network state. It may be desirable to have "
          "different values on different LSRs. Also, certain tunnels "
          "may not be re-optimized. This property specifies the "
          "re-optimization frequency for the LSR, in seconds. Default "
          "is 3600 (1 hour). The maximum interval is 604800 seconds (1 "
          "week). A value of 0 disables re- optimization."), 
       Units ( "Seconds" ), MaxValue ( 604800 )]
   uint32 ReoptimizationFreq = 3600;

      [Description (
          "Specifies the time interval in seconds at which traffic "
          "engineering information is flooded. Shorter intervals lead "
          "to more control overhead, more traffic in the network and "
          "more cycles wasted in processing this information at the "
          "routers. On the other hand longer intervals, make the route "
          "chosen for the tunnels to be less optimal with respect to "
          "the state of the network."), 
       Units ( "Seconds" )]
   uint16 FloodingInterval;

      [Description (
          "This property describes what happens when the MPLSTEService "
          "obtains knowledge about a new link coming into operation. "
          "The value 'OnLinkUp' (1) denotes that immediately after "
          "detecting the new link, a re-optimization step is "
          "performed. 'NextTimeInSchedule' (2) waits until the next "
          "time a re- optimization needs to take place. The frequency "
          "is defined by the ReoptimizationFreq property. And, 'Manual "
          "Trigger' (3) means the re-optimization MUST be triggered by "
          "manual interaction such as a human operator triggering the "
          "re-optimization."), 
       ValueMap { "0", "1", "2", "3" }, 
       Values { "Unknown", "OnLinkUp", "NextTimeInSchedule",
          "ManualTrigger" }]
   uint16 ReoptimizationLinkUp;
};


// ==================================================================
// MPLSCapabilities
// ==================================================================
   [Experimental, Version ( "2.8.1000" ), Description (
       "This class specifies the capabilities of an MPLSService or "
       "MPLSProtocolEndpoint (interface) on a Label Switched Router "
       "(LSR). The association CIM_ElementCapabilities relates the "
       "instance with its MPLS Service and/or Endpoint.")]
class CIM_MPLSCapabilities : CIM_Capabilities {

      [Description (
          "This is the minimum value of an MPLS label that this "
          "Endpoint or MPLSService is willing to receive. The values "
          "of an MPLSProtocolEndpoint may overrule the values "
          "specified for the LSR as a whole, based on the Endpoint's "
          "boolean property OverruleLSR."), 
       MappingStrings { "MIB.IETF|MPLS-LSR-MIB.MPLSInterfaceLabelMinIn" 
          }]
   uint32 LabelMinIn;

      [Description (
          "This is the maximum value of an MPLS label that this "
          "Endpoint or MPLSService is willing to receive. The values "
          "of an MPLSProtocolEndpoint may overrule the values "
          "specified for the LSR as a whole, based on the Endpoint's "
          "boolean property OverruleLSR."), 
       MappingStrings { "MIB.IETF|MPLS-LSR-MIB.MPLSInterfaceLabelMaxIn" 
          }]
   uint32 LabelMaxIn;

      [Description (
          "This is the minimum value of an MPLS label that this "
          "Endpoint or MPLSService is willing to send. The values of "
          "an MPLSProtocolEndpoint may overrule the values specified "
          "for the LSR as a whole, based on the Endpoint's boolean "
          "property OverruleLSR."), 
       MappingStrings { 
          "MIB.IETF|MPLS-LSR-MIB.MPLSInterfaceLabelMinOut" }]
   uint32 LabelMinOut;

      [Description (
          "This is the maximum value of an MPLS label that this "
          "Endpoint or MPLSService is willing to send. The values of "
          "an MPLSProtocolEndpoint may overrule the values specified "
          "for the LSR as a whole, based on the Endpoint's boolean "
          "property OverruleLSR."), 
       MappingStrings { 
          "MIB.IETF|MPLS-LSR-MIB.MPLSInterfaceLabelMaxOut" }]
   uint32 LabelMaxOut;
};


// ==================================================================
// MPLSProtocolEndpointStats
// ==================================================================
   [Experimental, Version ( "2.8.1000" ), Description (
       "This class represents the statistics for an MPLSProtocol "
       "Endpoint. The statistics are associated with the Endpoint "
       "using the relationship CIM_ElementStatisticalData.")]
class CIM_MPLSProtocolEndpointStats : CIM_StatisticalData {

      [Description (
          "This object contains the number of top-most labels that are "
          "in use at this point in time on this interface in the "
          "incoming direction."), 
       Gauge, 
       MappingStrings { 
          "MIB.IETF|MPLS-LSR-MIB.MPLSInterfaceInLabelsUsed" }]
   uint32 InLabelsUsed;

      [Description (
          "This object contains the number of top-most labels that are "
          "in use at this point in time on this interface in the "
          "outgoing direction."), 
       Gauge, 
       MappingStrings { 
          "MIB.IETF|MPLS-LSR-MIB.MPLSInterfaceOutLabelsUsed" }]
   uint32 OutLabelsUsed;

      [Description (
          "This object counts the number of labeled packets that have "
          "been received on this interface and were discarded because "
          "there was no matching cross-connect entry."), 
       Counter, 
       MappingStrings { 
          "MIB.IETF|MPLS-LSR-MIB.MPLSInterfaceFailedLabelLookup" }]
   uint32 FailedLabelLookups;

      [Description (
          "This object counts the number of outgoing MPLS packets that "
          "required fragmentation before transmission on this "
          "interface."), 
       Counter, 
       MappingStrings { 
          "MIB.IETF|MPLS-LSR-MIB.MPLSInterfaceOutFragments" }]
   uint32 NumberOfPacketsFragmented;
};


// ==================================================================
// MPLSLSP
// ==================================================================
   [Experimental, Version ( "2.8.1000" ), Description (
       "This class is used to represent an MPLS Label Switch Path "
       "(LSP). This is usually a path from an ingress to an egress "
       "label edge router, through a sequence of label switch routers. "
       "Sometimes an LSP is a series of hop-by-hop LSPs that go from "
       "the ingress to egress LSRs. For example, using unordered "
       "downstream unsolicited mode in LDP, the result is a series of "
       "'mini' LSPs along the path, each with incoming and outgoing "
       "labels, and a FEC to accept traffic onto the 'mini' LSP at "
       "each hop. \n"
       "\n"
       "An instance describes either an existing LSP, or the user's "
       "configurations of one to be established in the network. The "
       "boolean property, Established, indicates the state of the "
       "instance. \n"
       "\n"
       "Note that MPLSLSP subclasses from EnabledLogicalElement. This "
       "allows (via inherited properties) the explicit enabling and "
       "disabling of the path, as well as the ability to request that "
       "the path be 'tested' or shut down.")]
class CIM_MPLSLSP : CIM_EnabledLogicalElement {

      [Key, Description (
          "InstanceID opaquely identifies a unique instance of "
          "MPLSLSP. The InstanceID must be unique within a namespace. "
          "In order to ensure uniqueness, the value of InstanceID "
          "should be constructed in the following manner: The instance "
          "id consists of the IPAddress of the ingress LSR, combined "
          "with the LocalLSPId found in this class.")]
   string InstanceID;

      [Write, Description (
          "Boolean indicating whether or not the LSP currently exists "
          "in the network. Note that if the LSP is not established, "
          "then the OperationalStatus properties inherited from "
          "Managed SystemElement have no meaning.")]
   boolean Established;

      [Description (
          "Property to indicate the nesting level of this LSP. Note "
          "that this a shortcut counting the number of instances of "
          "the MPLSLSPInLSP association. It is advantageous to "
          "determine the nesting level directly, instead of traversing "
          "several associations to do so.")]
   uint16 NestingLevel;

      [Required, Description (
          "Property indicating a unique (per ingress LSR) LSP ID.")]
   uint16 LocalLSPId;

      [Description (
          "The IP addresses of the ingress node(s) (LERs) of the path. "
          "This is an array to allow for multipoint LSPs.")]
   string IngressIPAddresses[];

      [Description (
          "The IP addresses of the egress node(s) (LERs) of the path. "
          "This is an array to allow for multipoint LSPs.")]
   string EgressIPAddresses[];

      [Description (
          "Flag to indicate that the LSP ingress node may choose to "
          "reroute this LSP without tearing it down.")]
   boolean IngressMayReroute;

      [Description (
          "Flag to indicate that this LSP should be restored "
          "automatically after a failure occurs.")]
   boolean IsPersistent;
};


// ==================================================================
// MPLSTunnel
// ==================================================================
   [Experimental, Version ( "2.8.1000" ), Description (
       "This class represents an MPLS traffic engineering tunnel as "
       "defined in RFC 3031.")]
class CIM_MPLSTunnel : CIM_EnabledLogicalElement {

      [Key, Description (
          "InstanceID opaquely identifies a unique instance of "
          "SettingData. The InstanceID must be unique within a "
          "namespace. In order to ensure uniqueness, the value of "
          "InstanceID SHOULD be constructed in the following manner: \n"
          "<Vendor ID><ID> \n"
          "<Vendor ID> MUST include a copyrighted, trademarked or "
          "otherwise unique name that is owned by the business entity "
          "or a registered ID that is assigned to the business entity "
          "that is defining the InstanceID. (This is similar to the "
          "<Schema Name>_<Class Name> structure of Schema class "
          "names). The purpose of <Vendor ID> is to ensure that <ID> "
          "is truly unique across multiple vendor implementations. If "
          "such a name is not used, the defining entity MUST assure "
          "that the <ID> portion of the Instance ID is unique when "
          "compared with other instance providers. For DMTF defined "
          "instances, the <Vendor ID> is 'CIM'. \n"
          "<ID> MUST include a vendor specified unique identifier.")]
   string InstanceID;

      [Write, Description (
          "Boolean indicating whether or not the tunnel is currently "
          "signaled. Note that if the tunnel is not established, then "
          "the OperationalStatus properties inherited from Managed "
          "SystemElement have no meaning.")]
   boolean Established;

      [Description (
          "The IsResilient property indicates the recovery procedure "
          "to be applied to tunnels whose paths are impacted by "
          "faults. More specifically, it contains a boolean value that "
          "determines whether the tunnel is to be rerouted or not, "
          "when segments of its path fail. If set to true, the tunnel "
          "should be rerouted in case of failure; if false, it should "
          "not (which means that other means are applied, e.g. lower "
          "layer technologies for rerouting.)")]
   boolean IsResilient;

      [Description (
          "The bandwidth property denotes the complete bandwidth (in "
          "kilobits per second) required to be transported by the "
          "tunnel. Note, that the bandwidth is not directly "
          "implemented/ configured in a router, but the MPLSTunnel's "
          "Reserved Bandwidth property might be derived from this "
          "information."), 
       Units ( "KiloBits per Second" )]
   uint32 Bandwidth;

      [Description (
          "Reserved bandwidth for this tunnel in kilobits per second. "
          "In a load sharing environment, the bandwidth on each tunnel "
          "is set to be proportional to how traffic should be "
          "balanced. An LSR then load-shares into the tunnels based on "
          "the aggregate bandwidth. Note that it is possible to signal "
          "0 bandwidth for a pure best-effort tunnel."), 
       Units ( "KiloBits per Second" )]
   uint32 ReservedBandwidth;

      [Description (
          "Active bandwidth for this tunnel in kilobits per second. If "
          "the tunnel is not yet Established, then this property has "
          "no meaning. Knowing current Bandwidth is important because "
          "several path options may be configured for the tunnel. Note "
          "that it is possible to signal 0 bandwidth for a pure best- "
          "effort tunnel."), 
       Units ( "KiloBits per Second" )]
   uint32 ActiveBandwidth;

      [Description (
          "Due to changes in network and traffic characteristics, "
          "there may be a need to periodically change the paths of "
          "tunnels for optimization purposes. This should not be done "
          "too frequently as it could adversely affect the stability "
          "of the network. This property indicates how often such "
          "reoptimization should be performed for a specific tunnel. "
          "Note that the class, CIM_MPLSTEService, also has a "
          "reoptimization frequency property. The frequency specified "
          "in this class is specific to a particular tunnel, whereas "
          "the MPLSTEService's frequency is per service, on a Label "
          "Switched Router."), 
       Units ( "Seconds" ), MaxValue ( 604800 )]
   uint32 ReoptimizationFreq = 3600;

      [Description (
          "Indicates whether the tunnel is a candidate for "
          "re-optimization at all. If true the ReoptimizationFreq "
          "property should be taken into account. By default, a tunnel "
          "is re-optimized periodically.")]
   boolean Lockdown = true;

      [Description (
          "Resource classes and resource class affinities are "
          "described in [RFC2702]. Resource classes can be associated "
          "with links and advertised in routing protocols. Resource "
          "class affinities are used by RSVP-TE [RFC3209]. In order to "
          "be used, a link MUST pass three tests. One of them is "
          "against this property. \n"
          "\n"
          "ExcludeAllAffinity is one type of resource class affinity. "
          "It specifies a set of attribute filters for the tunnel, and "
          "a match on any of the filters renders a link unacceptable "
          "(it is excluded for consideration). This test takes the "
          "form, \n"
          "(MPLSProtocolEndpoint.ResourceClass & ExcludeAllAffinity) "
          "== 0."), 
       MappingStrings { 
          "MIB.IETF|MPLS-TE-MIB.MPLSTunnelExcludeAllAffinity" }]
   uint32 ExcludeAllAffinity;

      [Description (
          "Resource classes and resource class affinities are "
          "described in [RFC2702]. Resource classes can be associated "
          "with links and advertised in routing protocols. Resource "
          "class affinities are used by RSVP-TE [RFC3209]. In order to "
          "be used, a link MUST pass three tests. One of them against "
          "this property. \n"
          "\n"
          "IncludeAllAffinity is one type of resource class affinity. "
          "It specifies a set of attribute filters for the tunnel, and "
          "all of the filters must match for a link to be acceptable "
          "(i.e., pass this test). If IncludeAllAffinity is zero, then "
          "the test automatically passes. The test takes the form, \n"
          "(IncludeAllAffinity == 0) || "
          "(((MPLSProtocolEndpoint.ResourceClass & IncludeAllAffinity) "
          "^ IncludeAllAffinity) == 0)"), 
       MappingStrings { 
          "MIB.IETF|MPLS-TE-MIB.MPLSTunnelIncludeAllAffinity" }]
   uint32 IncludeAllAffinity;

      [Description (
          "Resource classes and resource class affinities are "
          "described in [RFC2702]. Resource classes can be associated "
          "with links and advertised in routing protocols. Resource "
          "class affinities are used by RSVP-TE [RFC3209]. In order to "
          "be used, a link MUST pass three tests. One of them against "
          "this property. \n"
          "\n"
          "IncludeAnyAffinity is one type of resource class affinity. "
          "It specifies a set of attribute filters for the tunnel, and "
          "any of the filters must match for a link to be acceptable "
          "(i.e., pass this test). If IncludeAllAffinity is zero, then "
          "the test automatically passes. The test takes the form, \n"
          "(IncludeAnyAffinity == 0) || "
          "((MPLSProtocolEndpoint.ResourceClass & IncludeAnyAffinity) "
          "!= 0)"), 
       MappingStrings { 
          "MIB.IETF|MPLS-TE-MIB.MPLSTunnelIncludeAnyAffinity" }]
   uint32 IncludeAnyAffinity;

      [Description (
          "Property to indicate the holding priority of an established "
          "tunnel. If the tunnel is not yet established, this property "
          "has no meaning. A new tunnel is allowed to preempt the "
          "resources of this tunnel only if its SetupPriority is "
          "smaller than the HoldingPriority of the established one. "
          "(See RFC3209 for additional information.) The value 0 is "
          "the highest priority."), 
       MinValue ( 0 ), MaxValue ( 7 ), 
       MappingStrings { "MIB.IETF|MPLS-TE-MIB.mplsTunnelHoldingPrio" }]
   uint8 HoldingPriority;

      [Description (
          "Guaranteed bandwidth tunnels can have setup and preemption "
          "priorities associated with them. These priorities determine "
          "if an existing tunnel can be preempted by a new one. The "
          "SetupPriority of the new tunnel is compared to the Holding "
          "Priority of the established one, to determine if the new "
          "tunnel can preempt the existing one. It does preempt if the "
          "SetupPriority in smaller than the HoldingPriority. Note "
          "that the value 0 is the highest priority."), 
       MinValue ( 0 ), MaxValue ( 7 ), 
       MappingStrings { "MIB.IETF|MPLS-TE-MIB.mplsTunnelSetupPrio" }]
   uint8 SetupPriority;

      [Description (
          "Flag to indicate that this tunnel should be restored "
          "automatically after a failure occurs.")]
   boolean IsPersistent;

      [Description (
          "Flag to indicate whether the loosely-routed hops of this "
          "tunnel are to be pinned.")]
   boolean IsPinned;

      [Description (
          "Flag to indicate that transit routers are permitted to use "
          "a local repair mechanism which may result in violation of "
          "the explicit routing of this tunnel. When a fault is "
          "detected on an adjacent downstream link or node, a transit "
          "router can reroute traffic for fast service restoration.")]
   boolean LocalProtectionAvailable;

      [Description (
          "In some situations, it is necessary to reroute a tunnel "
          "without disrupting traffic. This flag indicates whether the "
          "tunnel's route is adaptive.")]
   boolean IsAdaptive;

      [Description (
          "Flag to indicate whether the route for the tunnel is "
          "selected dynamically based on routing protocols - as "
          "opposed to being specified 'statically' via configuration, "
          "where a network operator or other external entity specifies "
          "the path of the tunnel hop by hop.")]
   boolean IsDynamicallyRouted;

      [Description (
          "Flag to indicate that the tunnel ingress node may choose to "
          "reroute this tunnel without tearing it down.")]
   boolean IngressMayReroute;

      [Description (
          "The purpose of this object is to uniquely identity a tunnel "
          "within a network. When the MPLS signaling protocol is "
          "rsvp(3), this value SHOULD mimic the Extended Tunnel Id "
          "field in the SESSION object. When the MPLS signaling "
          "protoocol is crldp(4), this value SHOULD mimic the Ingress "
          "LSR Router ID field in the LSPID TLV object."), 
       ModelCorrespondence { "CIM_MPLSTunnel.TunnelSignalingProtocol" }]
   uint32 IngressLSRId;

      [Description (
          "ID of egress LSR.")]
   uint32 EgressLSRId;

      [Override ( "ElementName" ), Description (
          "The canonical name assigned to the tunnel. This name can be "
          "used to refer to the tunnel on the LSR's console port.")]
   string ElementName;

      [Description (
          "The signaling protocol, if any, which was used to setup "
          "this tunnel."), 
       ValueMap { "0", "1", "2", "3", "4" }, 
       Values { "Unknown", "Other", "None", "RSVP", "CRLDP" }]
   uint8 TunnelSignalingProtocol;

      [Description (
          "Indicates which protocol created and is responsible for "
          "managing this tunnel. Values rsvp(3) and crldp(4) should "
          "NOT be used at the head-end of an MPLS tunnel."), 
       ValueMap { "0", "1", "2", "3", "4", "5" }, 
       Values { "Unknown", "Other", "Admin", "RSVP", "CRDLP",
          "Policy Agent" }]
   uint8 TunnelManagementOwner;

      [Description (
          "This value represents the priority for a tunnel in "
          "descending order, with 0 indicating the lowest priority, "
          "within a group of tunnels used for redundancy/load sharing. "
          "Tunnel group priorities are used to denote the priority at "
          "which a particular tunnel instance will supercede another. "
          "Instances of tunnels containing the same "
          "TunnelInstancePriority will be used for load sharing.")]
   uint32 TunnelInstancePriority ;

      [Description (
          "This property signifies the role that this tunnel "
          "entry/instance represents. The value MUST be set to head(2) "
          "at the originating point of the tunnel, to transit(3) at "
          "transit points along the tunnel (if transit points are "
          "supported), and to tail(4) at the terminating point of the "
          "tunnel (if tunnel tails are supported)."), 
       ValueMap { "0", "2", "3", "4" }, 
       Values { "Unknown", "Head", "Transit", "Tail" }]
   uint16 TunnelRole;
};


// ==================================================================
// MPLSReverseDirectionTunnel
// ==================================================================
   [Association, Experimental, Version ( "2.8.1000" ), Description (
       "Tunnels are unidirectional. This association relates two TE "
       "tunnels that carry traffic in reverse directions, creating a "
       "bi-directional connection.")]
class CIM_MPLSReverseDirectionTunnel : CIM_Dependency {

      [Override ( "Antecedent" ), Max ( 1 ), Description (
          "An MPLSTunnel, which operates in the reverse direction of "
          "the Dependent reference.")]
   CIM_MPLSTunnel REF Antecedent;

      [Override ( "Dependent" ), Max ( 1 ), Description (
          "An MPLSTunnel, which operates in the reverse direction of "
          "the Antecedent reference.")]
   CIM_MPLSTunnel REF Dependent;
};


// ==================================================================
// MPLSTunnelHop
// ==================================================================
   [Experimental, Version ( "2.8.1000" ), Description (
       "A destination in an MPLS tunnel. This may be specified by the "
       "user, calculated for the tunnel or actually in use. These "
       "different aspects are indicated by the HopDerivation "
       "enumeration.")]
class CIM_MPLSTunnelHop : CIM_RemoteServiceAccessPoint {

      [Description (
          "The method used to determine the destination."), 
       ValueMap { "0", "2", "3" }, 
       Values { "Unknown", "User", "Calculated" }]
   uint16 HopDerivation;
};


// ==================================================================
// MPLSHopInTunnel
// ==================================================================
   [Association, Experimental, Version ( "2.8.1000" ), Description (
       "This association represents the relationship between the "
       "tunnel head-end and the first hop in the tunnel's path. The "
       "hop may be of type Specified, Computed, or Actual.")]
class CIM_MPLSHopInTunnel : CIM_Dependency {

      [Override ( "Antecedent" ), Description (
          "The head-end of an MPLS traffic engineering tunnel.")]
   CIM_MPLSTunnelHop REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The MPLSTunnel whose first hop is described.")]
   CIM_MPLSTunnel REF Dependent;
};


// ==================================================================
// MPLSNextHopInTunnel
// ==================================================================
   [Association, Experimental, Version ( "2.8.1000" ), Description (
       "This association represents the relationship between two "
       "consecutive tunnels hops.")]
class CIM_MPLSNextHopInTunnel : CIM_Dependency {

      [Override ( "Antecedent" ), Max ( 1 ), Description (
          "Current MPLSTunnel hop.")]
   CIM_MPLSTunnelHop REF Antecedent;

      [Override ( "Dependent" ), Max ( 1 ), Description (
          "Next MPLSTunnel hop for the traversed path.")]
   CIM_MPLSTunnelHop REF Dependent;
};


// ==================================================================
// HostedMPLSTunnelHop
// ==================================================================
   [Association, Experimental, Version ( "2.8.1000" ), Description (
       "HostedMPLSTunnelHop defines a MPLSTunnelHop in the context of "
       "a scoping AutonomousSystem. It represents a MPLSTunnelHop that "
       "only has meaning in the context of an AutonomousSystem.")]
class CIM_HostedMPLSTunnelHop : CIM_HostedDependency {

      [Override ( "Antecedent" ), Min ( 1 ), Max ( 1 ), Description (
          "The scoping system.")]
   CIM_AutonomousSystem REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The collection defined in the context of a system.")]
   CIM_MPLSTunnelHop REF Dependent;
};


// ==================================================================
// MPLSFecOfTunnel
// ==================================================================
   [Association, Experimental, Version ( "2.8.1000" ), Description (
       "This association defines the forwarding equivalency class "
       "(FEC) for a traffic engineering tunnel. It is typically just "
       "an IP destination address - and can be defined using a "
       "FilterList. Although this is not truly a filter on the tunnel, "
       "the FilterList class is reused to describe the traffic on the "
       "tunnel.")]
class CIM_MPLSFecOfTunnel : CIM_Dependency {

      [Override ( "Antecedent" ), Max ( 1 ), Description (
          "The FilterList defining the FEC of the MPLSTunnel.")]
   CIM_FilterList REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The MPLSTunnel.")]
   CIM_MPLSTunnel REF Dependent;
};


// ==================================================================
// MPLSTunnelStats
// ==================================================================
   [Experimental, Version ( "2.8.1000" ), Description (
       "This class represents the statistics for an MPLSTunnel. The "
       "statistics are associated to the tunnel using the "
       "relationship, CIM_ElementStatisticalData.")]
class CIM_MPLSTunnelStats : CIM_StatisticalData {

      [Description (
          "Specifies the total time the primary tunnel has been "
          "active. A primary tunnel is found/designated in situations "
          "where multiple tunnels exist - i.e., when parallel or "
          "backup tunnels are defined."), 
       Units ( "Hundredths of a Second" ), Counter,
       MaxValue ( 4294967295 ), 
       MappingStrings { "MIB.IETF|MPLS-TE-MIB.MPLSTunnelPrimaryTimeUp" 
          }]
   uint32 TunnelPrimaryTimeUp;

      [Description (
          "Specifies the number of times the paths have changed for "
          "this tunnel."), 
       Counter, 
       MappingStrings { "MIB.IETF|MPLS-TE-MIB.MPLSTunnelPathChanges" }]
   uint32 TunnelPathChanges;

      [Description (
          "Specifies the time since the last path change for this "
          "tunnel."), 
       Units ( "Hundredths of a Second" ), Counter,
       MaxValue ( 4294967295 ), 
       MappingStrings { "MIB.IETF|MPLS-TE-MIB.MPLSTunnelLastPathChange" 
          }]
   uint32 TunnelLastPathChange;

      [Description (
          "Specifies the number of times the operational status of "
          "this tunnel has changed."), 
       Counter, 
       MappingStrings { 
          "MIB.IETF|MPLS-TE-MIB.MPLSTunnelStateTransitions" }]
   uint32 TunnelStateTransitions;

      [Description (
          "This value identifies the total time for which the the "
          "OperationalStatus of the tunnel is up (i.e., \"OK\"=2)."), 
       Units ( "Hundredths of a Second" ), Counter, 
       MappingStrings { "MIB.IETF|MPLS-TE-MIB.MPLSTunnelInstanceUpTime" 
          }]
   uint32 TunnelInstanceUpTime;
};


// ==================================================================
// MPLSPerformance
// ==================================================================
   [Experimental, Version ( "2.8.1000" ), Description (
       "This class contains performance information for MPLS entities "
       "such as an MPLS Endpoint or LSP Tunnel. The statistics are "
       "associated with the MPSL entity, using the general "
       "CIM_ElementStatisticalData relationship.")]
class CIM_MPLSPerformance : CIM_StatisticalData {

      [Description (
          "Denotes the number of packets lost."), 
       Counter]
   uint32 NumberOfPacketsLost;

      [Description (
          "Denotes the number of packets successfully transmitted."), 
       Counter]
   uint32 NumberOfPacketsTransmitted;

      [Description (
          "Denotes the number of octets transmitted."), 
       Counter]
   uint32 NumberOfOctets;

      [Description (
          "Denotes the average delay of the packets transmitted in "
          "milliseconds."), 
       Units ( "MilliSeconds" ), Gauge]
   uint16 Delay;

      [Description (
          "Denotes availability in hundredths of a percent."), 
       Units ( "Hundredths of Percent" ), MinValue ( 0 ),
       MaxValue ( 100000 )]
   uint16 Availability;
};


// ==================================================================
// MPLSSegment
// ==================================================================
   [Experimental, Abstract, Version ( "2.8.1000" ), Description (
       "This class is abstract, and generalizes the notion of incoming "
       "and outgoing MPLS segments on an "
       "interface/MPLSProtocolEndpoint. (Both In and Out Segment "
       "subclasses are derived from MPLSSegment.) An instance is "
       "defined in the context of an MPLSProtocolEndpoint. This is "
       "specified using the association, CIM_MPLSSegmentOnProtocolEP.")]
class CIM_MPLSSegment : CIM_LogicalElement {

      [Key, Description (
          "InstanceID opaquely identifies a unique instance of "
          "MPLSSegment. The InstanceID must be unique within a "
          "namespace. In order to ensure uniqueness, the value of "
          "InstanceID should be constructed in the following manner: \n"
          "<ID of the MPLSProtocolEndpoint>.<InLabel or TopLabel>.")]
   string InstanceID;

      [Description (
          "Denotes the entity that created and is responsible for "
          "managing this Segment. Note that the MappingString is "
          "depending on the instantiated class and corresponds to "
          "InSegmentOwner or OutSegmentOwner."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6", "7" }, 
       Values { "Unknown", "Other", "SNMP", "LDT", "RSVP", "CR-LDP",
          "Policy Agent", "CLI" }, 
       MappingStrings { "MIB.IETF|MPLS-LSR-MIB.MPLSInSegmentOwner",
          "MIB.IETF|MPLS-LSR-MIB.MPLSIOutSegmentOwner" }, 
       ModelCorrespondence { "CIM_MPLSSegment.OtherOwner" }]
   uint16 SegmentOwner;

      [Description (
          "If property SegmentOwner has a value 1 (\"Other\"), this "
          "property contains a string explaining the entity that "
          "created and manages the Segment."), 
       ModelCorrespondence { "CIM_MPLSSegment.SegmentOwner" }]
   string OtherOwner;
};


// ==================================================================
// MPLSSegmentStats
// ==================================================================
   [Experimental, Version ( "2.8.1000" ), Description (
       "The class represents the statistics for an In or Out "
       "MPLSSegment. The statistics are associated to the Segment "
       "using the relationship CIM_ElementStatisticalData.")]
class CIM_MPLSSegmentStats : CIM_StatisticalData {

      [Description (
          "This value represents the total number of octets "
          "received/sent by this Segment. Whether it denotes In or Out "
          "Segments depends on the instance associated with "
          "MPLSSegmentStats."), 
       Counter, 
       MappingStrings { "MIB.IETF|MPLS-LSR-MIB.MPLSInSegmentOctets",
          "MIB.IETF|MPLS-LSR-MIB.MPLSIOutSegmentOctets" }]
   uint32 NumberOfOctets;

      [Description (
          "Total number of packets received/sent by this Segment. "
          "Whether this value denotes In or Out Segments depends on "
          "the instance associated with MPLSSegmentStats."), 
       Counter, 
       MappingStrings { "MIB.IETF|MPLS-LSR-MIB.MPLSInSegmentPackets",
          "MIB.IETF|MPLS-LSR-MIB.MPLSOutSegmentPackets" }]
   uint32 NumberOfPackets;

      [Description (
          "The number of errored packets received/sent on this "
          "Segment. Whether this value denotes In or Out Segments "
          "depends on the instance associated with MPLSSegmentStats."), 
       Counter, 
       MappingStrings { "MIB.IETF|MPLS-LSR-MIB.MPLSInSegmentErrors",
          "MIB.IETF|MPLS-LSR-MIB.MPLSIOutSegmentErrors" }]
   uint32 NumberOfErrors;

      [Description (
          "The number of labeled packets received/sent on this "
          "Segment, which were chosen to be discarded even though no "
          "errors had been detected to prevent their being "
          "transmitted. One possible reason for discarding such a "
          "labeled packet could be to free up buffer space. Whether "
          "this value denotes In or Out Segments depends on the "
          "instance associated with MPLSSegmentStats."), 
       Counter, 
       MappingStrings { "MIB.IETF|MPLS-LSR-MIB.MPLSInSegmentDiscards",
          "MIB.IETF|MPLS-LSR-MIB.MPLSIOutSegmentDiscards" }]
   uint32 NumberOfDiscards;
};


// ==================================================================
// MPLSInSegment
// ==================================================================
   [Experimental, Version ( "2.8.1000" ), Description (
       "This class represents an incoming Segment on an MPLS "
       "interface.")]
class CIM_MPLSInSegment : CIM_MPLSSegment {

      [Required, Description (
          "The incoming label for this segment."), 
       MappingStrings { "MIB.IETF|MPLS-LSR-MIB.MPLSInSegmentLabel" }]
   uint32 InLabel;

      [Description (
          "The number of labels to pop from the incoming packet. "
          "Normally only the top label is popped from the packet, and "
          "used for all switching decisions. Note that technologies "
          "which do not support label popping should leave this value "
          "at its default (1)."), 
       MappingStrings { "MIB.IETF|MPLS-LSR-MIB.MPLSInSegmentNPop" }]
   uint32 NPop = 1;

      [Description (
          "Describes the address type expected on the incoming "
          "Segment. This is used when the last label is popped to know "
          "to which IP stack the packet is forwarded."), 
       ValueMap { "0", "1", "2" }, 
       Values { "Unknown", "IPv4", "IPv6" }, 
       MappingStrings { "MIB.IETF|MPLS-LSR-MIB.MPLSInSegmentAddrFamily" 
          }]
   uint16 AddressType;
};


// ==================================================================
// MPLSOutSegment
// ==================================================================
   [Experimental, Version ( "2.8.1000" ), Description (
       "This class represents an outgoing Segment on an MPLS "
       "interface.")]
class CIM_MPLSOutSegment : CIM_MPLSSegment {

      [Description (
          "This value indicates whether or not a top label should be "
          "pushed onto the outgoing packet's label stack. The value of "
          "this variable must be set to true if the outgoing interface "
          "does not support pop- and-go (for example an ATM interface) "
          "or if it is a tunnel origination."), 
       MappingStrings { 
          "MIB.IETF|MPLS-LSR-MIB.MPLSOutSegmentPushTopLabel" }]
   boolean PushTopLabel = true;

      [Required, Description (
          "If the property, PushTopLabel, is true then this represents "
          "the label that should be pushed onto the top of the "
          "outgoing packet's label stack. If PushTopLabel is false, "
          "then the value should be 0."), 
       MappingStrings { "MIB.IETF|MPLS-LSR-MIB.MPLSOutSegmentTopLabel" 
          }, 
       ModelCorrespondence { "CIM_MPLSOutSegment.PushTopLabel" }]
   uint32 TopLabel;
};


// ==================================================================
// MPLSCrossConnect
// ==================================================================
   [Experimental, Version ( "2.8.1000" ), Description (
       "This class specifies information for switching between "
       "Segments within a LSR. It is scoped by a Computer System, that "
       "is the Label Switched Router, via the HostedService "
       "association. Specific In/Out Segments are associated with the "
       "cross-connect using the relationship, MPLSSegmentInXC. The "
       "service can support point-to-point, point-to-multipoint and "
       "multipoint-to-point connections by defining multiple instances "
       "of the association. CrossConnect Services can be aggregated "
       "into an overarching MPLSService using the CIM_ServiceComponent "
       "association. And, the LSP to which the CrossConnect belongs is "
       "indicated by the association, CrossConnectLSP.")]
class CIM_MPLSCrossConnect : CIM_Service {

      [Description (
          "Denotes whether or not this CrossConnect entry and "
          "associated In and Out Segments should be restored "
          "automatically after failures."), 
       MappingStrings { "MIB.IETF|MPLS-LSR-MIB.MPLSXCIsPersistent" }]
   boolean IsPersistent;

      [Description (
          "Identifies a stack of labels to be pushed beneath the top "
          "label. Note that the top label identified in an instance of "
          "OutSegment ensures that all the components of a "
          "multipoint-to-point connection have the same outgoing "
          "label. This array is 'Ordered' to maintain the sequence of "
          "entries."), 
       ArrayType ( "Ordered" )]
   uint16 LabelStack[];
};


// ==================================================================
// MPLSQosPRTrfcProf
// ==================================================================
   [Experimental, Version ( "2.8.1000" ), Description (
       "A QoS traffic profile, which is associated to an LSP when QoS "
       "is guaranteed. The association ElementSetting ties the Setting "
       "to the LSP.")]
class CIM_MPLSQosPRTrfcProf : CIM_SettingData {

      [Description (
          "The peak traffic rate in kilobits per second."), 
       Units ( "KiloBits per Second" )]
   uint32 PRRate;

      [Description (
          "Traffic burst size in bytes."), 
       Units ( "Bytes" )]
   uint16 PRNormalBurst;

      [Description (
          "Traffic excess burst in bytes."), 
       Units ( "Bytes" )]
   uint16 PRExcessBurst;
};


// ==================================================================
// MPLSCRLSPTrfcProf
// ==================================================================
   [Experimental, Version ( "2.8.1000" ), Description (
       "Class to represent the Constraint-based Routed LSP (CR-LSP) "
       "traffic parameters as specified in [RFC3212].")]
class CIM_MPLSCRLSPTrfcProf : CIM_MPLSQosPRTrfcProf {

      [Description (
          "Property to indicate at what granularity the CDR (allocated "
          "to the CR-LSP) is made available."), 
       ValueMap { "0", "1", "2" }, 
       Values { "Unspecified", "Frequently", "Very Frequently" }]
   uint16 CRLSPFrequency;

      [Description (
          "Property to indicate the CR-LSP's relative share (in "
          "percent) of the possible excess bandwidth above its "
          "committed rate."), 
       Units ( "Percent" ), MinValue ( 0 ), MaxValue ( 100 )]
   uint8 CRLSPWeight;

      [Description (
          "Property to indicate the CR-LSP's committed data rate in "
          "bytes per second."), 
       Units ( "Bytes per Second" )]
   uint16 CRLSPCommitedDataRate;

      [Description (
          "Property to indicate the CR-LSP's committed burst size in "
          "bytes."), 
       Units ( "Bytes" )]
   uint16 CRLSPCommitedBurstSize;
};


// ==================================================================
// MPLSSegmentOnProtocolEP
// ==================================================================
   [Association, Experimental, Version ( "2.8.1000" ), Description (
       "An MPLSSegment is defined in the context of an MPLS Endpoint. "
       "This association makes that relationship explicit.")]
class CIM_MPLSSegmentOnProtocolEP : CIM_Dependency {

      [Override ( "Antecedent" ), Min ( 1 ), Max ( 1 ), Description (
          "The MPLSProtocolEndpoint which scopes the Segment.")]
   CIM_MPLSProtocolEndpoint REF Antecedent;

      [Override ( "Dependent" ), Description (
          "An MPLSSegment on the ProtocolEndpoint.")]
   CIM_MPLSSegment REF Dependent;
};


// ==================================================================
// MPLSSegmentInXC
// ==================================================================
   [Association, Experimental, Version ( "2.8.1000" ), Description (
       "Defines the association between an In or Out Segment and a "
       "CrossConnect Service. The Segment is dependent on the Cross "
       "Connect for switching within the LSR.")]
class CIM_MPLSSegmentInXC : CIM_Dependency {

      [Override ( "Antecedent" ), Description (
          "The MPLSCrossConnect.")]
   CIM_MPLSCrossConnect REF Antecedent;

      [Override ( "Dependent" ), Description (
          "An MPLSSegment dependent on the CrossConnect for switching.")]
   CIM_MPLSSegment REF Dependent;
};


// ==================================================================
// MPLSFilterAtXC
// ==================================================================
   [Association, Experimental, Version ( "2.8.1000" ), Description (
       "The association denotes a filter list defining what traffic is "
       "mapped into the CrossConnect Service. A filter list is "
       "associated with the CrossConnect at the originating LSR.")]
class CIM_MPLSFilterAtXC : CIM_Dependency {

      [Override ( "Antecedent" ), Max ( 1 ), Description (
          "A FilterList defining what traffic is mapped into the "
          "CrossConnect Service.")]
   CIM_FilterList REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The CrossConnect whose traffic is filtered.")]
   CIM_MPLSCrossConnect REF Dependent;
};


// ==================================================================
// MPLSCurrentlyAssignedLSP
// ==================================================================
   [Association, Experimental, Version ( "2.8.1000" ), Description (
       "Associates a traffic trunk with an LSP that is currently "
       "carrying its traffic.")]
class CIM_MPLSCurrentlyAssignedLSP : CIM_Dependency {

      [Override ( "Antecedent" ), Description (
          "The LSP carrying the traffic of the trunk.")]
   CIM_MPLSLSP REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The MPLSTrafficTrunk which is signaling using the LSP.")]
   CIM_MPLSTunnel REF Dependent;

      [Description (
          "The preference for the use of the LSP, if more than one LSP "
          "is available to a trunk. Possible values are 0 to 7, with 7 "
          "indicating the highest preference."), 
       MinValue ( 0 ), MaxValue ( 7 )]
   uint16 Preference;

      [Write, Description (
          "This property is used to indicate the relative proportion "
          "of traffic to be carried by parallel LSPs, specified as a "
          "percentage from 0 to 100. The value is defined by the "
          "network user/administrator to indicate how a LSPtunnel's "
          "bandwidth should be set on a router. It allows load "
          "distribution across multiple parallel LSP tunnels, between "
          "two nodes. Quoting from RFC2702, 'In many practical "
          "situations, the aggregate traffic between two nodes may be "
          "such that no single link can carry the load. In this case, "
          "the only feasible solution is to appropriately divide the "
          "aggregate traffic into sub-streams and route the "
          "sub-streams through multiple paths between the two nodes. "
          "This problem can be addressed by instantiating multiple LSP "
          "tunnels between the two nodes, such that each traffic trunk "
          "carries a proportion of the aggregate traffic.' The "
          "proportion of traffic carried by each such LSP tunnel is "
          "specified by the TrafficProportion property."), 
       Units ( "Percent" ), MinValue ( 0 ), MaxValue ( 100 )]
   uint8 TrafficProportion;
};


// ==================================================================
// MPLSBackupLSP
// ==================================================================
   [Association, Experimental, Version ( "2.8.1000" ), Description (
       "Identifies an LSP as a backup LSP for a traffic trunk.")]
class CIM_MPLSBackupLSP : CIM_Dependency {

      [Override ( "Antecedent" ), Description (
          "The backup LSP for the traffic trunk.")]
   CIM_MPLSLSP REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The traffic trunk using the LSP for backup.")]
   CIM_MPLSTunnel REF Dependent;

      [Description (
          "The preference for the use of the LSP, if more than one LSP "
          "is available to a trunk. Possible values are 0 to 7, with 7 "
          "indicating the highest preference."), 
       MinValue ( 0 ), MaxValue ( 7 )]
   uint16 Preference;
};


// ==================================================================
// MPLSLSPInLSP
// ==================================================================
   [Association, Experimental, Aggregation, Version ( "2.8.1000" ), 
    Description (
       "Defines the nesting relationship of LSPs within LSPs. "
       "Arbitrary hierarchies of LSPs are possible.")]
class CIM_MPLSLSPInLSP : CIM_Component {

      [Aggregate, Override ( "GroupComponent" ), Description (
          "The higher-level LSP containing another LSP.")]
   CIM_MPLSLSP REF GroupComponent;

      [Override ( "PartComponent" ), Description (
          "The LSP that is nested in the one referenced as "
          "GroupComponent.")]
   CIM_MPLSLSP REF PartComponent;
};


// ==================================================================
// MPLSCrossConnectLSP
// ==================================================================
   [Association, Experimental, Version ( "2.8.1000" ), Description (
       "Defines the LSP to which the CrossConnect belongs.")]
class CIM_MPLSCrossConnectLSP : CIM_Dependency {

      [Override ( "Antecedent" ), Max ( 1 ), Description (
          "The LSP.")]
   CIM_MPLSLSP REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The CrossConnect belonging to the LSP.")]
   CIM_MPLSCrossConnect REF Dependent;

      [Description (
          "The XcType property defines whether a CrossConnect is at "
          "the terminating end (\"Term\", 1), or originating end "
          "(\"Orig\", 2) of an LSP. A value of 4, \"Normal\", "
          "indicates the CrossConnect is switching through an LSP on "
          "an intermediate node. A value of 3, \"Special\", implies a "
          "terminating LSP for special traffic, e.g. signaling "
          "neighbor discovery, etc. Reserved MPLS labels with values 0 "
          "through 15 are used."), 
       ValueMap { "1", "2", "3", "4" }, 
       Values { "Term", "Orig", "Special", "Normal" }]
   uint16 XcType;

      [Description (
          "This property defines the order of the CrossConnects in an "
          "LSP. An incrementally higher number indicates the next "
          "Cross Connect in the ordered sequence. Note that the first "
          "CrossConnect must be of type 'Orig', and the last of type "
          "'Term' (see the property, XcType).")]
   uint16 XcOrder;
};


// ===================================================================
// end of file
// ===================================================================
